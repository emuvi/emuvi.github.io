<html style><!--
 Page saved with SingleFile 
 url: https://www.stroustrup.com/bs_faq.html 
 saved date: Wed Feb 10 2021 10:37:41 GMT-0300 (Horário Padrão de Brasília)
--><meta charset=utf-8>
<title> Stroustrup: FAQ </title>
<link type=image/x-icon rel="shortcut icon" href="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><link rel=canonical href=https://www.stroustrup.com/bs_faq.html></head>
<body bgcolor=FFFBFB>
<center>
<a href=http://www.morganstanley.com/>Morgan Stanley</a>
|
<a href=http://www.cs.columbia.edu/>Columbia University</a>
|
<a href=https://www.chu.cam.ac.uk/>Churchill College, Cambridge</a>
</center>
<p>
</p><center>
<a href=https://www.stroustrup.com/index.html>home</a>
|
<a href=https://www.stroustrup.com/C++.html>C++</a>
|
<a href=https://www.stroustrup.com/bs_faq.html>FAQ</a>
|
<a href=https://www.stroustrup.com/bs_faq2.html>technical FAQ</a>
|
<a href=https://www.stroustrup.com/papers.html>publications</a>
|
<a href=https://www.stroustrup.com/WG21.html>WG21 papers</a>
|
<a href=https://www.stroustrup.com/4th.html>TC++PL</a>
|
<a href=https://www.stroustrup.com/tour2.html>Tour++</a>
|
<a href=https://www.stroustrup.com/programming.html>Programming</a>
|
<a href=https://www.stroustrup.com/dne.html>D&amp;E</a>
|
<a href=https://www.stroustrup.com/bio.html>bio</a>
|
<a href=https://www.stroustrup.com/interviews.html>interviews</a>
|
<a href=https://www.stroustrup.com/videos.html>videos</a>
|
<a href=https://www.stroustrup.com/quotes.html>quotes</a>
|
<a href=https://www.stroustrup.com/applications.html>applications</a>
|
<a href=https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>guidelines</a>
|
<a href=https://www.stroustrup.com/compilers.html>compilers</a>
</center>
<center>
<h1><a href=https://www.stroustrup.com/index.html>Bjarne Stroustrup</a>'s FAQ</h1>
</center>
<p align=right>
Modified November 23, 2020.
<p>
These are questions that people ask me often.
If you have better questions or comments on the answers,
feel free to email me.
Please remember that I can't spend all of my time improving my homepages.
<p>
This page concentrates on personal opinions and general questions related to
philosophy.
For questions that more directly relate to C++ language features and the
use of C++, see 
<a href=https://isocpp.org/faq>The C++ Foundation's FAQ</a> or
my
<a href=https://www.stroustrup.com/bs_faq2.html>C++ style and technique FAQ</a>.
For C++ terminology and concepts, see my
<a href=https://www.stroustrup.com/glossary.html>C++ glossary</a>.
For links to useful sources of C++ information, see
<a href=https://www.stroustrup.com/C++.html>my C++ page</a> and
<a href=https://www.stroustrup.com/C++11FAQ.html>my C++11 FAQ</a>.
For information about my books (incl. reviews and support information), see
<a href=https://www.stroustrup.com/books.html>my book list</a>.
For papers and ISBNs for translations of my books, see
<a href=https://www.stroustrup.com/papers.html>my publication list</a>.
<p>
Translations:
<ul>
<li>
<a href=https://www.stroustrup.com/bsfaqcn.html>Chinese (simplified)</a>
<li>
<a href=http://william.cswiz.org/CPPbook/bs_faq.html>Chinese (traditional)</a>.
<li>
<a href=http://www.designcontest.com/show/bs-faq-be>Belorussian</a>
<li>
<a href=https://wiki--travel.com/bs_faq.html>Dutch</a>
</ul>
<p>
<h1>Index</h1>
<ul>
<li><a href=#general>General</a>
<li><a href=#learning>Learning C++</a>
<li><a href=#standard>Standardization</a>
<li><a href=#books>Books</a>
<li><a href=#other>Other languages</a>
<li><a href=#C>C and C++</a>
<li><a href=#history>History of C++</a>
<li><a href=#etc.>Etc. C++ questions</a>
<li><a href=#personal>Personal</a>
</ul>
<p>
<ul>
<li>
<a name=general>General</a>:
<ul>
<li>
<a href=#class>
What's so great about classes?</a>
<li>
<a href=#oop>
What is "OOP" and what's so great about it?</a>
<li>
<a href=#generic>
What is "generic programming" and what's so great about it?</a>
<li>
<a href=#what-is>
What is C++?</a>
<li>
<a href=#unsafe>
Why does C++ allow unsafe code?</a>
<li>
<a href=#multiparadigm>
What is "multiparadigm programming"?</a>
<li>
<a href=#decline>
Is C++ in decline?</a>
<li>
<a href=#improve>
What's being done to improve C++?</a>
<li>
<a href=#true>
Is it true that ...?</a>
</ul>
<li>
<a name=learning>Learning C++</a>:
<ul>
<li>
<a href=#best-book>
What is the best book to learn C++ from?</a>
<li>
<a href=#How-long>
How long does it take to learn C++?</a>
<li>
<a href=#prerequisite>
Knowing C is a prerequisite for learning C++, right?</a>
<li>
<a href=#learn-pure>
Should I learn a pure OO language before C++ to become a real OO programmer?</a>
<li>
<a href=#how-to-start>
How do I start learning C++?</a>
<li>
<a href=#homework>
Will you help me with my homework?</a>
<li>
<a href=#free>
Where can I get a free C++ compiler?</a>
<li>
<a href=#improve-my-C++-programs>
What's the best way to improve my C++ programs?</a>
<li>
<a href=#which-programming-language>
Does it matter which programming language I use?</a>
<li>
<a href=#background>
Where can I learn about the background of C++?</a>
</ul>
<li>
<a name=standard>Standardization</a>:
<ul>
<li>
<a href=#spoil-C++>
Did the ANSI/ISO standards committee spoil C++?</a>
<li>
<a href=#When-standard>
When will we have a C++ standard?</a>
<li>
<a href=#machine-readable-standard>
Where can I get a machine-readable version of the standard?</a>
<li>
<a href=#remove-from-C++>
Are there any features you'd like to remove from C++?</a>
<li>
<a href=#garbage-collection>
Why doesn't C++ have garbage collection?</a>
<li>
<a href=#gui>
Why doesn't C++ have a GUI?</a>
<li>
<a href=#threads>
Why doesn't C++ support threads?</a>
<li>
<a href=#C++03>
What is the difference between C++98 and C++14?</a>
<li>
<a href=#When-next-standard>
What will the next standard look like?</a>
</ul>
<li>
<a name=books>Books</a>:
<ul>
<li>
<a href=#4th>
When will you publish a 4th edition of "The C++ Programming Language"?</a>
<li>
<a href=#e-books>
Do you like e-books?</a>
<li>
<a href=#machinereadable>
Where do I find free machine-readable copies of your books?</a>
<li>
<a href=#3rd-programming>
What's the difference between the "TC++PL" and "Programming" books?</a>
</ul>
<li>
<a name=other>Other languages</a>:
<ul>
<li>
<a href=#Java>
Is Java the language you would have designed if you didn't have to be compatible with C?</a>
<li>
<a href=#Csharp>
What do you think of C#?</a>
<li>
<a href=#CppCLI>
What do you think of C++/CLI?</a>
<li>
<a href=#EC++>
What do you think of EC++?</a>
<li>
<a href=#from-Smalltalk>
C++ got its Object-Oriented concepts from Smalltalk?</a>
<li>
<a href=#Ada>
Do you really recommend Ada over C++ for larger projects?</a>
<li>
<a href=#compare>
Would you compare C++ to "some language"?</a>
<li>
<a href=#Others-do-compare>
Others do compare their languages to C++; doesn't that annoy you?</a>
<li>
<a href=#diatribes>
You won't compare C++ to other languages, but you write diatribes about C++?</a>
<li>
<a href=#advanced>
How can a legacy language like C++ compete with modern, advanced languages?</a>
<li>
<a href=#portability>
Why are you so keen on portability?</a>
</ul>
<li>
<a name=C>C and C++</a>:
<ul>
<li>
<a href=#C-is-better>
C is better than C++ for small projects, right?</a>
<li>
<a href=#C-is-subset>
Is C a subset of C++?</a>
<li>
<a href=#difference>
What is the difference between C and C++?</a>
<li>
<a href=#merge>
Do you really think that C and C++ could be merged into a single language?</a>
<li>
<a href=#C-slash>
What do you think of C/C++?</a>
<li>
<a href=#Hello-world>
Why is the code generated for the "Hello world" program
ten times larger for C++ than for C?</a>
<li>
<a href=#whyC>
Why did you make C++ (almost) compatible with C?</a>
</ul>
<li>
<a name=history>History of C++</a>:
<ul>
<li>
<a href=#invention>
When was C++ invented?</a>
<li>
<a href=#why>
Why did you invent C++?</a>
<li>
<a href=#why-ATT>
Why did AT&amp;T support the development of C++?</a>
<li>
<a href=#revenues>
Do you own C++?</a>
<li>
<a href=#name>
Where did the name "C++" come from?</a>
<li>
<a href=#bootstrapping>
Which language did you use to write C++?</a>
<li>
<a href=#understand>Did you really not understand what you were doing?</a>
</ul>
<li>
<a name=etc.>Etc. C++ questions</a>:
<ul>
<li>
<a href=#big>
Why is C++ so BIG?</a>
<li>
<a href=#Object-Oriented-language>
Is C++ an Object-Oriented language?</a>
<li>
<a href=#legacy>
What is "legacy code"?</a>
<li>
<a href=#number-of-C++-users>
Is the number of C++ users still doubling every year?</a>
<li>
<a href=#use-C++>
Does anyone use C++ these days?</a>
<li>
<a href=#use-C++-for-OS>
Why isn't C++ used for Operating Systems?</a>
<li>
<a href=#boost>
What do you think of Boost?</a>
<li>
<a href=#metaprogramming>
What do you think of template metaprogramming?</a>
<li>
<a href=#C++success>
Did you expect C++ to become such a success?</a>
<li>
<a href=#certification>
What's a good certification for C++ programmers?</a>
<li>
<a href=#recommend>
What C++ compiler do you recommend? Which libraries?</a>
<li>
<a href=#list>
Are lists evil?</a>
</ul>
<li>
<a name=personal>Personal</a>:
<ul>
<li>
<a href=#pronounce>
How do you pronounce "Bjarne Stroustrup"?</a>
<li>
<a href=#ask>
Can I ask you a question?</a>
<li>
<a href=#email>
Why don't you answer your email?</a>
<li>
<a href=#looks>
Why don't you make your website look modern?</a>
<li>
<a href=#impostor>
Is "bjarne" an impostor?</a>
<li>
<a href=#Swedish>
You are Swedish?</a>
<li>
<a href=#really-say-that>Did you really say that?</a>
<li>
<a href=#IEEE>
Did you really give an interview to IEEE?</a>
<li>
<a href=#morgan>
Why did you go to work at Morgan Stanley?</a>
<li>
<a href=#tamu>
Why did you go to work at Texas A&amp;M University?</a>
<li>
<a href=#btl>
Why did you go to work at Bell labs?</a>
<li>
<a href=#working-on-now>
What are you working on now?</a>
</ul>
</ul>
<p>
<hr>
<h2><a name=pronounce>
How do you pronounce "Bjarne Stroustrup?"</a></h2>
It can be difficult for non-Scandinavians.
The best suggestion I have heard yet was "start by saying it a few times
in Norwegian, then stuff a potato down your throat and do it again :-)"
Here is a
<a href=https://www.stroustrup.com/pronounciation.wav>wav file</a>.
<p>
For people who can't receive sound, here is a suggestion:
Both of my names are pronounced with two syllables: Bjar-ne
Strou-strup.
Neither the B nor the J in my first name are stressed and the NE
is rather weak so maybe Be-ar-neh or By-ar-ne would give an idea.
The first U in my second name really should have been a V making the
first syllable end far down the throat: Strov-strup.
The second U is a bit like the OO in OOP, but still short; maybe
Strov-stroop will give an idea.
<p>
Yes, this probably is the most frequently asked question :-)
<p>
P.S. My first name is Bjarne - not Bjorn (not a name),
Bjørn (a related but different name), nor Barney (an unrelated name).
My second name is Stroustrup - not Stroustroup, Stroustrop, Strustrup,
Strustrop, Strustroup, Straustrup, nor Straustroup (documents using each of
these misspellings can be found using google).
<p>
<hr>
<h2><a name=ask>
Can I ask you a question?</a></h2>
Certainly.
I try to answer my email.
However, please try to avoid asking a question that is answered in my
homepages.
Also, please don't rely on a prompt answer.
I get a <b>lot</b> of email.
<p>
Here are links to
<ul>
<li><a href=https://www.stroustrup.com/bio.html>biographical information</a>
<li><a href=https://www.stroustrup.com/C++.html>C++ information and links</a>
<li><a href=https://www.stroustrup.com/papers.html>papers</a> (incl. many that can be downloaded)
<li><a href=https://www.stroustrup.com/books.html>books</a> (incl. reviews, errata, and a few chapters that can be downloaded)
<li><a href=https://www.stroustrup.com/interviews.html>interviews</a>
</ul>
<p>
<hr>
<h2><a name=email>
Why don't you answer your email?</a></h2>
I do, but I get a lot of email.
I estimate that I reply to more than 95% of the (non spam) messages I receive.
However, sometimes I get overwhelmed.
Some messages are lost in my mailbox, some are delayed until I can find time,
some are delayed until I get around to answering a set of related messages
(this often happens to comments about potential errors in my books).
Unfortunately, longer and more thoughtful messages are more likely to get
delayed than simple ones that have simple answers.
<p>
Also, if you mail me, please try to make sure that I can reply to you.
I really hate it when I have written and sent a reply, just to find that the
return address is invalid or inaccessible. 
<p>
Two kinds of messages have a relatively high chance of getting lost: homework
questions and questions of the form "how do I use this proprietary library?".
I'm a bit sad about not answering the latter questions because often the
person asking doesn't understand that the DOS, Windows, or whatever interface
from C++ is not part of the C++ standard (and I cannot keep up with the huge
number of
<a href=http://www.trumphurst.com/cpplibs1.html>C++ libraries</a>).
If you fail to receive an answer,
please consider if your question was of one of these kinds.
<p>
Also, unless you give your name, I am now likely to delete the message unread.
This is a new policy.
I was never a great fan of pseudonyms,
but I find that the chance of a polite
technical conversation with the kind of person who thinks it cool to hide behind a name like
suuupergeeek or coolGuy3 is getting too low for me to bother trying.
<p>
<hr>
<h2><a name=looks>Why don't you make your website look modern?</a></h2>
I'm a "contents provider" not a website designer.
I can use my time to improve the contents or the looks, but not both.
<p>
What looks "cool and modern" to someone is often considered bad
taste by someone else, and fashions change fast.
Also,
very plain html downloads and displays faster than anything else, and many
people still suffer from slow web connections.
<p>
<hr>
<h2><a name=impostor>Is "bjarne" an impostor?</a></h2>
Probably not.
Most of the newsgroup postings, interviews, etc. claiming to come from me
do come from me.
The obvious exception is the infamous <a href=#IEEE>IEEE "interview"</a>,
which is now 20+ years old and I find rather unfunny.
If in doubt, consider the style and contents of the suspect message, check for other
postings in the forum, or ask.
<p>
<hr>
<h2><a name=class>What is so great about classes?</a></h2>
<p>
Classes are there to help you organize your code and to reason about your programs.
You could roughly equivalently say that classes are there to help you avoid making mistakes
and to help you find bugs after you do make a mistake.
In this way, classes significantly helps maintenance.
<p>
A class is the representation of an idea, a concept, in the code. An object of a class represents
a particular example of the idea in the code. Without classes, a reader of the code would have
to guess about the relationships among data items and functions - classes make such relationships
explicit and "understood" by compilers. With classes, more of the high-level structure of your
program is reflected in the code, not just in the comments.
<p>
A well-designed class presents a clean and simple interface to its users, hiding its
representation and saving its users from having to know about that representation.
If the representation shouldn't be hidden - say, because users should be able to change
any data member any way they like - you can think of that class as "just a plain old data structure";
for example:
<pre>	struct Pair {
         	string name, value;
	};
</pre>
Note that even data structures can benefit from auxiliary functions, such as constructors.
<p>
When designing a class, it is often useful to consider what's true for every object of the
class and at all times. Such a property is called an invariant. For example, the invariant
of a vector could be that its representation consists of a pointer to a number of elements
and that number of elements is stored in an integer. It is the job of every constructor to
establish the class invariant, so that every member function can rely on it.
Every member function must leave the invariant valid upon exit.
This kind of thinking is particularly useful for classes that manage resource,
such as locks, sockets, and files. For example, a file handle class will have the invariant
that it holds a pointer to an open file. The file handle constructor opens the file.
Destructors free resources acquired by constructors. For example, the destructor for
a file handle closes the file opened by the constructor:
<pre>	class File_handle {
	public:
		File_handle(const char* n, const char* rw)
			{ f = fopen(n,rw); if (f==0) throw Open_failure(n); }
		~File_handle() { fclose(f); } // destructor
		// ...
	private:
		FILE* f;
	};
</pre>
If you haven't programmed with classes, you will find parts of this explanation obscure and
you'll underestimate the usefulness of classes.
Look for examples. Like all good textbooks,
<a href=https://www.stroustrup.com/4th.html>TC++PL</a> has lots of examples.
For a less detailed and easier to approach book, see
<a href=https://www.stroustrup.com/tour2.html>A Tour of C++</a>.
Most modern C++ libraries consist (among other things) of classes and a library tutorial
is one of the best places to look for examples of useful classes.
<p>
<hr>
<h2><a name=oop>What is "OOP" and what's so great about it?</a></h2>
<p>
There are lots of definitions of "object oriented", "object-oriented programming",
and "object-oriented programming languages". For a longish explanation of what
I think of as "object oriented", read
<a href=https://www.stroustrup.com/oopsla.pdf>Why C++ isn't just an object-oriented programming language</a>.
That said, object-oriented programming is a style of programming originating with
Simula (more than 40 years ago!) relying of encapsulation, inheritance, and polymorphism.
In the context of C++ (and many other languages with their roots in Simula),
it means programming using class hierarchies and virtual functions to allow
manipulation of objects of a variety of types through well-defined interfaces
and to allow a program to be extended incrementally through derivation.
<p>
See <a href=#class>What's so great about classes?</a>
for an idea about what great
about "plain classes". The point about arranging classes into a class hierarchy
is to express hierarchical relationships among classes and use those relationships to simplify code.
<p>
To really understand OOP, look for some examples. For example, you might have
two (or more) device drivers with a common interface:
<pre>	class Driver {	// common driver interface
	public:
		virtual int read(char* p, int n) = 0;	// read max n characters from device to p
							// return the number of characters read
		virtual bool reset() = 0;	// reset device
		virtual Status check() = 0;	// read status
	};
</pre>
This Driver is simply an interface.
It is defined with no data members and a set of pure virtual functions.
A Driver can be used through this interface and many different kinds of drivers
can implement this interface:
<pre>	class Driver1 : public Driver { // a driver
	public:
		Driver1(Register);	// constructor
		int read(char*, int n);	
		bool reset();
		Status check();
	private:
		// implementation details, incl. representation
	};

	class Driver2 : public Driver { // another driver
	public:
		Driver2(Register);
		int read(char*, int n);	
		bool reset();
		Status check();
	private:
		// implementation details, incl., representation
	};
</pre>
Note that these drivers hold data (state) and objects of them can be created.
They implement the functions defined in Driver. We can imagine a driver being used like this:
<pre>	void f(Driver&amp; d)	// use driver
	{
		Status old_status = d.check();	
		// ...
		d.reset();
		char buf[512];
		int x = d.read(buf,512);
		// ...
	}
</pre>
The key point here is that f() doesn't need to know which kind of driver it uses;
all it needs to know is that it is passed a Driver;
that is, an interface to many different kinds of drivers.
We could invoke f() like this:
<pre>	void g()
	{
		Driver1 d1(Register(0xf00));	// create a Driver1 for device
						// with device register at address 0xf00

		Driver2 d2(Register(0xa00));	// create a Driver2 for device
						// with device register at address 0xa00
		// ...
		int dev;
		cin &gt;&gt; dev;

		if  (dev==1) 
			f(d1);	// use d1
		else
			f(d2);	// use d2
		// ...
	}
</pre>
Note that when f() uses a Driver the right kind of operations are implicitly chosen at run time.
For example, when f() is passed d1, d.read() uses Driver1::read(), whereas when f() is passed d2,
d.read() uses Driver2::read(). This is sometimes called run-time dispatch or dynamic dispatch.
In this case there is no way that f() could know the kind of device it is called with because
we choose it based on an input.
<p>
Please note that object-oriented programming is not a panacea. "OOP" does not simply mean "good"
- if there are no inherent hierarchical relationships among the fundamental concepts in your problem
then no amount of hierarchy and virtual functions will improve your code. The strength of OOP
is that there are many problems that can be usefully expressed using class hierarchies - the main
weakness of OOP is that too many people try to force too many problems into a hierarchical mould.
Not every program should be object-oriented. As alternatives, consider
<a href=#class>plain classes</a>,
<a href=#generic>generic programming</a>,
and free-standing functions (as in math, C, and Fortran).
<p>
<hr>
<h2><a name=generic>What is "generic programming" and what's so great about it?</a></h2>
<p>
Generic programming is programming based on parameterization:
You can parameterize a type with another
(such as a vector with its element types) and an algorithm with another
(such as a sort function with
a comparison function). The aim of generic programming is to generalize a useful algorithm or data
structure to its most general and useful form. For example, a vector of integers is fine and so is
a function that finds the largest value in a vector of integers. However, a generic solution that
provides a vector of any type the user cares to use and a function that finds the largest value in
any vector is better still:
<pre>	vector&lt;string&gt;::iterator p = find(vs.begin(), vs.end(), "Grail");

	vector&lt;int&gt;::iterator q = find(vi.begin(), vi.end(), 42);
</pre>
These examples are from the STL (the containers and algorithms part of the ISO C++ standard library);
for a brief introduction, see
<a href=https://www.stroustrup.com/tour.html2>A Tour of C++</a> from
<a href=https://www.stroustrup.com/4th.html>TC++PL</a>.
<p>
 In C++20 we can simplify that example to
<pre>	auto p = find(vs, "Grail");

	auto q = find(vi, 42);
</pre>
<p>
Generic programming is in some ways more flexible than object-oriented programming.
In particular, it does not depend on hierarchies.
For example, there is no hierarchical
relationship between an int and a string.
Generic programming is generally more structured than OOP;
in fact, a common term used to describe generic programming is "parametric polymorphism",
with "ad hoc polymorphism"
being the corresponding term for object-oriented programming.
In the context of C++, generic programming
resolves all names at compile time; it does not involve dynamic (run-time) dispatch.
This has led generic programming to become dominant in areas where run-time performance is important.
<p>
Please note that generic programming is not a panacea.
There are many parts of a program that need no parameterization and many examples
where run-time dispatch (OOP) is needed.
<p>
<hr>
<h2><a name=unsafe>Why does C++ allow unsafe code?</a></h2>
That is, why does C++ support operations that can be used to violate the rules of static
(compile-time) type safety?
<ul>
<li> to access hardware directly
 (e.g. to treat an integer as a pointer to (address of) a device register)
<li> to achieve optimal run-time and space performance
 (e.g. unchecked access to elements of an array and unchecked access to
 an object through a pointer)
<li> to be compatible with C
</ul>
That said, it is a good idea to avoid unsafe code like the plague whenever you don't actually need
one of those three features:
<ul>
<li> don't use casts
<li> keep arrays out of interfaces (hide them in the innards of high-performance functions
 and classes where they are needed and write the rest of the program using proper
 strings, vectors, etc.)
<li> avoid void* (keep them inside low-level functions and data structures if
 you really need them and present type safe interfaces, usually templates, to your users)
<li> avoid unions
<li> if you have any doubts about the validity of a pointer, use a smart pointer instead,
<li> don't use "naked" news and deletes (use containers, resource handles, etc., instead)
<li> don't use ...-style variadic functions ("printf style")
<li> Avoid <a href=https://www.stroustrup.com/bs_faq2.html#macro>macros</a> excpt for include guards
</ul>
Almost all C++ code can follow these simple rules.
Please don't be confused by the fact that you cannot follow these rules if you write C code or
C-style code in C++.
<p>
For an ambitious project to make C++ easier to use and safer without damaging its efficiency or flexibility, see
<a href=https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>the Core C++ Guidelines</a>.
<p>
<hr>
<h2><a name=best-book>What is the best book to learn C++ from?</a></h2>
There is no one book that is best for every person.
There couldn't be one.
People are too different in the way they learn, in what they
already know, in what they need, in what they want, and in what kind of
effort
they are willing to make.
There are quite a few excellent books on C++.
<p>
For people who haven't programmed before or come from another language and want a
relatively gentle introduction to modern C++, consider
<a href=https://www.stroustrup.com/programming.html>Programming: Principles and Practice using C++</a>.
This is the book I wrote for a freshman (1st year university students) programming class
and it has benefitted from three years of classroom use.
<p>
For people who are programmers and willing to learn new concepts
and techniques from a classical textbook, I recommend
<a href=https://www.stroustrup.com/4th.html> The C++ Programming Language (4th edition)</a>.
The book is aimed at programmers with some experience and a wish to master C++.
It is not aimed at non-programmers trying to learn their first programming language
or casual programmers trying to gain a superficial understanding of C++ as fast
as possible.
Consequently, this book focuses on concepts and techniques and goes to some pain to
be complete and precise.
It describes "pure C++," that is, the language independently of
any particular software development environment or foundation
library (except the standard library, of course).
It contain comprehensive coverage of the standard library.
<p>
If you are already an experienced programmer and want a quick overview of what C++ has to offer, consider
<a href=https://www.stroustrup.com/tour2.html>A Tour of C++ (second efition)</a>.
It presents the major features of C++ and its standard library in 200 pages.
<p>
If you want to know why C++ is the way it is, have a look at
<a href=https://www.stroustrup.com/dne.html> The Design and Evolution of C++</a>
(D&amp;E). Understanding the design criteria and constraints
helps writing better programs.
<a href=https://dl.acm.org/doi/pdf/10.1145/3386320>Thriving in a Crowded and Changing World: C++ 2006-2020</a>
can be seen as an up-to-date follow-up to D&amp;E.
<p>
<hr>
<h2><a name=How-long>How long does it take to learn C++?</a></h2>
That depends on what you mean by "learning."
If you are a C programmer you can learn enough C++ to make you more
effective at C-style programming in a day.
<p>
At <a href=http://www.cs.tamu.edu/>TAMU</a>,
we use <a href=https://www.stroustrup.com/programming.html>Programming: Principles and Practice using C++</a>
to get freshmen (1st year students) through the fundamentals of C++ and the
programming techniques it support (notably
<a href=#oop>object-oriented programming</a> and
<a href=#generic>generic programming</a>)
in a semester.
<p>
On the other hand, if you want to be fully comfortable with all the
major C++ language constructs, with data abstraction, Object-Oriented
programming, generic programming, Object-Oriented design, etc., you can
easily spend a year or two - if you aren't already acquainted with
those techniques (say, from Java or C#).
<p>
Is that then the time it takes to learn C++?
Maybe, but then again, that is the timescale we have to consider to
become better designers and programmers. If a dramatic change of the
way
we work and think about building systems isn't our aim, then
why bother to learn a new language?
Compared to the time required to learn to play the piano well or to
become fluent in a foreign (natural) language, learning a new and
different programming language and programming style is easy.
<p>
For more observations about learning C++ see
<a href=https://www.stroustrup.com/dne.html> D&amp;E</a> or
<a href=https://www.stroustrup.com/learn.html>a note from comp.lang.c++</a>
that I wrote some time ago.
<p>
<hr>
<h2><a name=prerequisite>
Knowing C is a prerequisite for learning C++, right?</a></h2>
Wrong. The common subset of C and C++ is easier to learn than C.
There will be less type errors to catch manually (the C++ type
system is stricter and more expressive), fewer tricks
to learn (C++ allows you to express more things without
circumlocution),
and better libraries available.
The best initial subset of C++ to learn is not "all of C".
<p>
See
<a href=https://www.stroustrup.com/new_learning.pdf>Learning Standard C++ as a New Language</a>
for a discussion of the choice of C++ constructs, techniques, and libraries
for early learning.
For an example of books that takes that approach systematically, see
Stroustrup: <a href=https://www.stroustrup.com/programming.html>Programming: Principles and Practice using C++</a> and
Koenig&amp;Moo: "Accelerated C++" from Addison Wesley's
<a href=http://www.awl.com/cseng/series/indepth/index.shtml>C++ In Depth</a> series.
<p>
<hr>
<h2><a name=learn-pure>
Should I learn a pure OO language before C++ to become a real OO programmer?</a></h2>
No. Learning something new is almost always a good idea.
However, each language is different and has it's own styles and quirks.
Code written in some supposedly "pure" OO style modeled on some other language (quirks and all)
is often sub-optimal and frustrating when too literally transcribed into C++.
Also, "writing <b>just</b> pure Object-oriented code" is not one of my ideals; see my OOPSLA keynote
<a href=https://www.stroustrup.com/oopsla.pdf>
Why C++ isn't just an Object-Oriented Programming Language</a>.
If you want to become a good C++ programmer and don't have a few months
to spare, concentrate on C++ and the concepts it embodies.
<p>
<hr>
<h2><a name=how-to-start>How do I start learning C++?</a></h2>
Naturally,
that strongly depends on what you already know and your reasons for
learning C++.
If you are a novice at programming, I strongly recommend that you find 
an experienced programmer to help you.
Otherwise, the inevitable mistakes about language concepts and practical
problems with the implementation you use can magnify into serious frustrations.
<p>
You'll need a textbook for learning C++.
This is the case even when your implementation comes with ample on-line
documentation.
The reason is that 
language and library documentation together with sample code are not good
teachers of concepts.
Typically such sources are silent about why things are the way they are and
what benefits you can expect (and which you shouldn't expect) from a technique.
Focus on concepts and techniques rather than language-technical details.
<p>
When choosing a book, look for one that presents Standard C++ and use the
standard library facilities in an integrated manner from the start.
For example, reading a string from input should look something like
<pre>	string s;	// Standard C++ style
	cin &gt;&gt; s;
</pre>
and not like this
<pre>	char s[MAX];	/* Standard C style */
	scanf("%s",s);
</pre>
Look for book recommendations from programmers with solid C++ experience.
<p>
I recommend
<a href=https://www.stroustrup.com/programming.html>Programming: Principles and Practice using C++</a>,
but remember that
<a href=#best-book>no one book is the best for everyone</a>.
Have a look at the
<a href=http://www.accu.org/>book reviews</a>
on the ACCU (The Association of C and C++ Users) site.
<p>
Aim to write idiomatic C++: avoid simply writing code in the style of your
previous language using C++ syntax; there is little to be gained from
simply changing syntax.
<p>
<hr>
<h2><a name=homework>Will you help me with my homework?</a></h2>
No. Sorry. I don't do (other people's) homework.
I get too many requests for help with homework and help with finding
bugs in student programs to be able to find the time.
Anyway, having a distant expert fix your programs is not the best way to learn.
Try finding a local person with C++ experience that you can ask for
guidance.
A good mentor is the best help a student can have; maybe that's why they
are not easy to find.
<p>
Also, no, I will not suggest "a good project for a student to work on".
My experience is that learning enough about a student and
his/her course to know what level of difficulty is required and what kind of
project is of interest takes time.
To think of a good project is then non-trivial,
and to explain exactly what the project is and how to approach it can take
several messages and several hours. I just don't have that kind of time.
Remember, these request come at least weekly. Finally, some students seem
to have the idea that if I suggest a project, I am morally obliged to
provide quite detailed help in its completion.
<p>
Ideas: Look at the exercises in
<a href=https://www.stroustrup.com/4th.html>TC++PL</a>
or other good textbooks. Many of those exercises are designed to keep a student
busy for several days, and reading those exercises can inspire an enterprising
student to so something similar.
Or look at the non-computer-science part of your world: Maybe a biology project
could use support for a new measurement device or a friend studying history
could use an improved database interface. Many of the best projects and the
best uses of computers are outside traditional computer science.
<p>
See also <a href=https://www.stroustrup.com/bs_faq2.html>my C++ style and techniques FAQ</a>.
Real novices facing their first "read some data, do something to it, and
produce some output" exercise might be interested in
<a href=https://www.stroustrup.com/bs_faq2.html#simple-program>a very simple program</a>
or
<a href=https://www.stroustrup.com/bs_faq2.html#read-string>a program reading a string from input</a>.
<p>
<hr>
<h2><a name=free>Where can I get a free C++ compiler?</a></h2>
From lots of places; see
<a href=https://www.stroustrup.com/compilers.html>my C++ compilers list</a>.
<p>
<hr>
<h2><a name=Swedish>You are Swedish?</a></h2>
No. I'm Danish. Have a look at my
<a href=https://www.stroustrup.com/bio.html>biography</a>.
<p>
<hr>
<h2><a name=improve-my-C++-programs>
What's the best way to improve my C++ programs?</a></h2>
I couldn't say. That depends on how you use it.
Most people underestimate abstract classes and templates.
Conversely, most people seriously overuse casts and macros.
Have a look at one of my
<a href=https://www.stroustrup.com/papers.html>papers</a> or
<a href=https://www.stroustrup.com/books.html>books</a> for ideas.
One way of thinking of abstract classes and templates is as
interfaces that allow a more clean and logical presentation
of services than is easy to provide through functions or
single-rooted class hierarchies.
See my
<a href=https://www.stroustrup.com/bs_faq2.html>Style and techniques FAQ</a> for some specific examples and ideas.
<p>
<hr>
<h2><a name=which-programming-language>
Does it matter which programming language I use?</a></h2>
Yes, but don't expect miracles.
Some people seem to believe that a programming language can or at least
should
solve most of their problems with system building.
They are condemned to search forever for the perfect programming
language
and become repeatedly disappointed.
Others dismiss programming languages as unimportant "implementation
details"
and put their money into development processes and design methods.
They are condemned to program in COBOL, C, and proprietary design
languages
forever.
A good language - such as C++ - can do a lot for a designer and a
programmer,
as long as its strengths and limitations are clearly understood and
respected.
<p>
<hr>
<h2><a name=spoil-C++>
Did the ANSI/ISO standards committee spoil C++?</a></h2>
No. They/we did a good job.
You can quibble with details (and I do, sometimes loudly), but I'm happy with the
language and the
new standard library.
ISO C++ is a better and more coherent language than earlier versions of
C++.
You can write much more elegant and maintainable C++ programs today
than was
possible when the standards process started.
The new standard library is also a real boon.
The provision of strings, lists, vectors, maps, and basic algorithms
for
such fundamental types makes a major difference to the way one can
approach
C++.
See the library chapters of
<a href=https://www.stroustrup.com/4th.html> The C++ Programming Language</a>
or <a href=https://www.stroustrup.com/tour2.pdf> A Tour of C++</a>
or
<a href=https://www.stroustrup.com/papers.html>one of my recent papers</a>.
<p>
<hr>
<h2><a name=When-standard>When will we have a C++ standard?</a></h2>
We have had one since 1998.
The second standard came in 2011.
<p>
The current standard,
<a href=https://www.stroustrup.com/C++11FAQ.html>C++14</a>,
was approved in 2014 and good implementationt are
<a href=http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport>already shipping</a>.
C++11/C++14 is described in the
<a href=https://www.stroustrup.com/books.html>current editions of my books</a>.
<p>
<hr>
<h2><a name=machine-readable-standard>
Where can I get a machine-readable version of the standard?</a></h2>
<p>
The C++ standard (ISO/IEC 14882) is available for downloading at the
<a href=http://webstore.ansi.org/>the ANSI Electronic Store</a>.
Search for "14882", to find "INCITS/ISO/IEC 14882-2003 Programming Languages - C++"
The cost is (as I write this) US$30.00 payable on-line via credit card.
The downloaded document is in PDF form, about 3Mb total size.
<p>
 Look at <a href=https://isocpp.org/std/the-standard>ISOcpp/standardization</a>
 for informations about the standard, standaridzation effort, and a late working paper (available for free).
The current standard is C++17, but C++20 has been approved and will become official late 2020.
<p>
Be warned that the standard is not a tutorial;
even expert programmers will do better learning about C++ and new C++ features from a textbook.
<hr>
<h2><a name=remove-from-C++>
Are there any features you'd like to remove from C++?</a></h2>
Not really.
People who ask this kind of question usually think of one of the major
features such as multiple inheritance,
exceptions, templates, or run-time type identification.
C++ would be incomplete without those.
I have reviewed their design over the years, and together with the
standards
committee I have improved some of their details,
but none could be removed without doing damage.
<p>
Most of the features I dislike from a language-design perspective
(e.g., the declarator syntax and array decay) are part
of the C subset of C++ and couldn't be removed without doing harm to
programmers working under real-world conditions.
C++'s C compatibility was a key language design decision rather than a
marketing gimmick.
Compatibility has been difficult to achieve and maintain,
but real benefits to real programmers resulted, and still result today.
By now, C++ has features that allow a programmer to refrain from using
the most troublesome C features. For example, standard library
containers
such as vector, list, map, and string can be used to avoid most tricky
low-level pointer manipulation.
<p>
<hr>
<h2><a name=C++03>
What is the difference between C++98 and C++11 and C++14?</a></h2>
And C++17 and C++20.
That's not something that is easily summarized.
For most practical purposes, C++20 is backwards compatible with C++11, that is almost ocompletely backwards compatible with C++98.
There is a compatibility section at the back of the standard detailing compatibility issues.
<p>
<hr>
<h2><a name=When-next-standard>
What will the next standard look like?</a></h2>
That will be C++17.
It is a bit early to say for sure what C++17 will offer, but it is intended to be a major upgrade and 
I presented some of my ideas at <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4492.pdf>a 2015 standards meeting</a>.
Note that it is unlikely that I get all that I wish for.
For a complete list of proposals, see
<a href=http://www.open-std.org/jtc1/sc22/wg21>the WG21 site</a>.
<p>
<hr>
<h2><a name=4th>
When will you publish a 4th edition of "The C++ Programming Language"?</a></h2>
It is in print: <a href=https://www.stroustrup.com/4th.html>The C++ Programming Language (4th Edition)</a>.
Addison-Wesley. ISBN 978-0321563842.
May 2013.
<p>
It is now shipping from amazon, from
<a href="http://click.linksynergy.com/fs-bin/click?id=/TDPPeRUMm4&amp;offerid=163217.10000230&amp;type=1&amp;subid=0">the publisher</a><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAUUAAAALAAAAAABAAEAAAICRAEAOw==" width=1 height=1 border=0>, and elsewhere.
<p>
There are no current plans for a 5th edition.
<hr>
<h2><a name=3rd-programming>
What's the difference between the "TC++PL" and "Programming" books?</a></h2>
<a href=https://www.stroustrup.com/4th.html>The C++ Programming Language</a>
is primarily written for experienced programmers who wants to learn C++.
It's style is that of a professional book.
<a href=https://www.stroustrup.com/programming.html>Programming - Principles and Practice using C++</a>
is primarily written for people who wants to learn programming using C++.
It can be used/read by people with no or only weak programming background
as well as people who want to learn modern programming techniques,
such as object-oriented programming and generic programming, as supported by C++.
It's style is that of a text book.
<p>
A summary:
<ul>
<li>
<a href=http://www.stroustrup.com/4th.html>TC++PL4</a>:
For programmers who wants to know modern C++ in depth (C++11)
<li> 
<a href=http://www.stroustrup.com/tour2.html>Tour++</a>:
For programmers who wants an overview of modern C++ (C++17 plus a bit of C++20)
<li>
<a href=http://www.stroustrup.com/programming.html>PPP</a>:
For novices and programmers with a weak understanding of C++ (C++14)
<li>
<a href=http://www.stroustrup.com/dne.html>D&amp;E</a>:
For people interested in design principles and history
<li>
Others: Don't read them; they are outdated</ul>
<hr>
<h2><a name=e-books>
Do you like e-books?</a></h2>
I like e-books for crime stories and SF.
I don't think they are ready for serious technical information.
For that, I prefer paper - even if I have to wait a couple of days and carry some extra weight. A good textbook, opened on a table,will show two pages - an area about three times that of an ebook reader. Reading on a large, good-quality screen is OK, just OK.
<p>
<hr>
<h2><a name=machinereadable>
Where do I find free machine-readable copies of your books?</a></h2>
There are no legal free machine readable copies of my books.
If you see a copy freely available it must be a copyright violation
(that is, it was stolen).
<p>
Addison-Wesley offers electronic versions through
<a href=http://my.safaribooksonline.com/0201700735>Safari online books service</a> and elsewhere.
<p>
<hr>
<h2><a name=recommend>
What C++ compiler do you recommend? Which libraries?</a></h2>
I don't recommend.
It wouldn't be fair.
However, do get a recent release. Naturally, newer compilers approximate the
ISO standard much more closely than compilers from a few years ago.
<p>
For an incomplete list of C++ implementations, see
<a href=https://www.stroustrup.com/compilers.html>my C++ compilers list</a>.
<p>
Also, where possible, prefer the standard library to non-standard "foundation
libraries" and try to minimize use of proprietary extensions.
<p>
<hr>
<h2><a name=list>
Are lists evil?</a></h2>
According to some corners of the Web, I am under the impression that vectors are always better than linked lists and that I don't know about other data structures, such as trees (e.g. <b>std::set</b>) and hash tables (e.g., <b>std::unordered_map</b>).
Obviously, that's absurd.
<p>
The problem seems to be an interesting little exercise that John Bentley once proposed to me: Insert a sequence of random integers into a sorted sequence, then remove those elements one by one as determined by a random sequece of positions: Do you use a vector (a contiguously allocated sequence of elements) or a linked list?
For example, see
<a href=http://www.stroustrup.com/Software-for-infrastructure.pdf>Software Development for Infrastructure</a>.
I use this example to illustrate some points, encourage thought about algorithms, data structures, and machine architecture, concluding:
<ul>
<li>don't store data unnecessarily,
<li>keep data compact, and
<li>access memory in a predictable manner. 
</ul>
Note the absence of ``list'' and ``vector'' in the conclusion. Please don't confuse an example with what the example is meant to illustrate.
<p>
I used that example in several talks, notably:
<ul>
<li><a href=http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style>My 2012 ``Going Native'' Keynote</a>.
</ul>
This video has been popular: It has been downloaded more than 250K times (plus another 50K+ times at verious other sites). My impression is that many viewers failed to understand that the purpose of that example is to illustrate some general principles and to make people think.
Initially, most people say ``List of course!'' (I have tried asking that question many times) because of the many insertions and deletions ``in the middle'' (lists are good at that).
That answer is completely and dramatically wrong, so it is good to know why.
<p>
I have been using the example for years, and had graduate students implement and measure dozens of variants of this exercise and different exercises.
Examples and measurements by others can be found on the Web.
Of course,
<ul>
<li>I have tried maps (they are much better than lists, but still slower than vectors)
<li>I have tried much larger elements sizes (eventually lists come into their own)
<li>I have used binary search and direct insertion for vectors (yes, they speed up even further)
<li>I checked my theory (no I'm not violating any big-O complexity rule; it is just that some operations can be dramatically more expensive for one data structure compared to another)
<li>I have preallocated links (that's better than <b>std::list</b> but the traversal still kills performance)
<li>I have used singly-linked lists, <b>forward_list</b>s, (that doesn't make much difference, but makes it a bit harder to ensure that the user code is 100% equivalent)
<li>I know (and say) that 500K lists are not common (but that doesn't matter for my main point).
We use many structures (large and small) where there is a choice between linked and contiguous reprentation.
<li>I know that for insertion <b>push_front()</b> is faster for <b>std::list</b>s and <b>push_back()</b>s is faster for <b>vector</b>s.
You can construct examples to illustrate that, but this example is not one of those.
</ul>
My point is <i>not</i> about lists as such.
They have their uses, but this example isn't one of them.
Please don't confuse the example with what the example is used to illustrate. This example is about use of memory: We very often create a data structure, do some computation on it requiring access (often, traversal), and then delete it. The ordered sequence is simply an example of such use and the example is presented to get people to think about what matters in such cases. My suggestion is:
<ul>
<li>don't store data unnecessarily,
<li>keep data compact, and
<li>access memory in a predictable manner. 
</ul>
I emphasize the importance of cache effects.
In my experience, all but true experts tend to forget those when algorithms are discussed.
<p>
And, yes, my recomendation is to use <b>std::vector</b> by default.
More generally, use a contiguous representation unless there is a good reason not to.
Like C, C++ is designed to do that by default.
<p>
Also, please don't make statements about performance without measurements.
I have seen a case where changing a zero-to-two-element list to a zero-to-two-element vector made a factor-of-two difference to an algorithm. I didn't expect that. Nor did other experts looking at the code. 
<hr>
<h2><a name=Java>
Is Java the language you would
have designed if you didn't have to be compatible with C?</a></h2>
No. Java isn't even close.
If people insist on comparing C++ and Java - as they seem to do -
I suggest they read
<a href=https://www.stroustrup.com/dne.html> The Design and Evolution of C++</a>
(D&amp;E) to see why C++ is the way it is,
and consider both languages in the light of the design criteria
I set for C++. Those criteria will obviously differ from the criteria
of Sun's Java team.
Despite the syntactic similarities, C++ and Java are very different
languages.
In many ways, Java seems closer to Smalltalk than to C++.
<p>
Much of the relative simplicity of Java is - like for most new
languages -
partly an illusion and partly a function of its incompleteness.
As time passes, Java will grow
significantly in size and complexity. It will double or triple in size
and grow implementation-dependent extensions or libraries.
That is the way every commercially
successful language has developed. Just look at any language you
consider successful on a large scale. I know of no exceptions,
and there are good reasons for this phenomenon.
[I wrote this before 2000; now (2012),
the language part of the Java 7 specification is slightly longer in terms of number of pages than the ISO C++11 language specification.]
<p>
I have commented (negatively) about Java hype and ascribed much of Java's success to marketing.
For example, see <a href=https://www.stroustrup.com/hopl-almost-final.pdf>my HOPL-3 paper</a>.
Today (2010), the claims made about Java are more reality based and less gratuitously derogative about alternatives.
This was not always so. For example, compare the <a href=https://www.stroustrup.com/1995_Java_whitepaper.pdf>original 1995 Java white paper</a>
with the versions you find on the web (sometimes labelled "the original Java whitepaper"); page 69 would be a good place to start.
<p>
Java isn't platform independent; it is a platform.
Like Windows, it is a proprietary commercial platform.
That is, you can write programs for Windows/Intel or Java/JVM, and in
each
case you are writing code for a platform owned by a single corporation
and tweaked for the commercial benefit of that corporation.
It has been pointed out that you can write programs in any language for
the JVM and associated operating systems facilities. However, the JVM,
etc.,
are heavily biased in favor of Java. It is nowhere near being a general
reasonably language-neutral VM/OS.
<p>
Personally, I'll stick to reasonably portable C++ for most of the kind
of work I think most about and use a variety of languages for the rest.
<p>
<hr>
<h2><a name=Csharp>
What do you think of C#?</a></h2>
I have no comments on C# as a language.
It will take a lot to persuade me that the world needs yet another
proprietary language.
It will be especially hard to persuade me that it needs a language that is
closely integrated with a specific proprietary operating system.
<p>
If you want to write exclusively for the .Net platform, C# isn't the worst alternative,
but remember that C++ is a strongly supported - though less strongly hyped - alternative
on that platform.
<p>
<hr>
<h2><a name=CppCLI>
What do you think of C++/CLI?</a></h2>
C++/CLI is a set of extensions to ISO C++ that provides an extremely complete "binding" of C++
to Microsoft's CLI (Common Language Infrastructure).
It has been standardized by ECMA (ECMA-372). I am happy that it makes every feature of the CLI
easily accessible from C++ and happy that C++/CLI is a far better language than its predecessor
"Managed C++".
However, I am less happy that C++/CLI achieves its goals by essentially augmenting C++ with
a separate language feature for each feature of CLI
(interfaces, properties, generics, pointers, inheritance, enumerations, and much, much more).
This will be a major source of confusion (whatever anyone does or says).
The wealth of new language facilities in C++/CLI compared to ISO Standard C++ tempts programmers
to write non-portable code that (often invisibly) become intimately tied to Microsoft Windows.
<p>
The CLI provides a set of interfaces (to system facilities) that are very different from traditional
interfaces to operating system facilities and applications.
In particular, these interfaces have semantics that
cannot be completely or conveniently expressed in conventional programming languages.
One way of describing CLI is as a (partial) "platform" or "virtual machine". It consists of a
large set of language features (inheritance, methods, loop constructs, callback mechanisms, etc.),
supporting a large set of foundation libraries (the BCL), plus an elaborate system of metadata.
The CLI is sometimes
described as "language neutral". However, a language that doesn't accept a large subset of
these facilities cannot use even basic .Net facilities
(or future Microsoft Windows facilities, assuming that Microsoft's plans don't change)
and a language that cannot express <b>all</b> of these
features cannot be used for the implementation of resources meant to be usable by other languages.
Thus, CLI is "language neutral" only in the sense that every language must support all of the CLI
features to be "first-class" on .Net.
<p>
I prefer a binding to be a few primitives, expressible as simple function calls and simple
data structures in any language, possibly encapsulated in language-specific libraries.
For the CLI, this can at best be done for consumers of CLI facilities only. A language
used to produce CLI modules must be able to express all of the CLI facilities, including
the metadata.
Only a language that can do that can be considered a systems programming language on .Net. 
Thus, the Microsoft C++ team concluded that only build-in language facilities
are acceptable to their customers.
Their design reflects a view that accepts absolutely no restrictions on what part of CLI can be
expressed in C++ with the C++/CLI extensions,
absolutely no verbosity compared to other languages when using CLI facilities,
and absolutely no overheads compared to other languages.
They aim at preserving C++ as the dominant systems programming language for Windows.
<p>
As ever,
<a href=#portability>I place a heavy emphasis on portability</a> and
recommend people to design applications so that access to system-specific facilities are through
well-defined interfaces specified in ISO C++ (e.g., not to use C++/CLI directly).
On Windows, this will sometimes be inconvenient compared with using C++/CLI
facilities directly, but it's the only way to gain portability and a degree of vendor independence.
Obviously, that arms-length approach to the CLI cannot be maintained if the purpose of a piece of
code is to provide a CLI interface to be consumed by other code.
Please note that I recognize the need for system-specific extensions and that Microsoft is not
the only C++ vendor with such extensions, I just strongly prefer to deal with such extensions
through a "thin interface" specified in ISO standard C++.
<p>
How to deal with system-specific extensions is inherently a difficult question.
The Microsoft C++ team, especially Herb Sutter, has kept up an active dialog with (other) members
of the ISO C++ standards committee so that the relationship between ISO C++ and its superset C++/CLI
will eventually be worked out.
We have a long record of constructive joint work in the ISO C++ committee.
Also, to minimize confusion between ISO C++ and the C++/CLI extensions, Microsoft is now revising
their Visual C++ documentation to try to clearly distinguish C++/CLI from ISO C++
(plain unqualified C++ means ISO C++).
I hope others will follow that lead.
<p>
On the difficult and controversial question of what the CLI binding/extensions to C++ is to be called,
I prefer C++/CLI as a shorthand for "The CLI extensions to ISO C++".
Keeping C++ as part of the name reminds people what is the base language and will
help keep C++ a proper subset of C++ with the C++/CLI extensions.
The <a href=#merge>C/C++ compatibility problems</a>
demonstrate how important it is to keep that subset property.
<p>
Here are some documents related to C++/CLI:
<ul>
<li>
<a href=http://www.ecma-international.org/publications/standards/Ecma-372.htm>The ECMA C++/CLI standard</a>.
<li>
<a href=https://www.stroustrup.com/uk-objections.pdf>The UK ISO C++ panel's objection</a> (incl. some code examples).
<li>
<a href=http://www.plumhall.com/ecma/ECMA372ReviewResponse.pdf>ECMA's answer to the UK (and other) objections</a>.
<li>
<a href=http://www.gotw.ca/publications/C++CLIRationale.pdf>Herb Sutter's design rationale for C++/CLI</a>
</ul>
<p>
<hr>
<h2><a name=portability>
Why are you so keen on portability?</a></h2>
Successful software is long-lived; life-spans of decades are not uncommon.
A good application/program often outlives the hardware it was designed for,
the operating system it was written for, the data base system it initially used, etc.
Often, a good piece of software outlives the companies that supplied the basic technologies
used to build it.
<p>
Often a successful application/program have customers/users who prefer a variety of platforms.
The set of desirable platforms change as the user population changes. Being tied to a single
platform or single vendor, limits the application/program's potential use.
<p>
Obviously, complete platform independence is incompatible with the ability to use all platform
specific facilities. However, you can often approximate platform independence for an application
by accessing platform facilities through a "thin interface" representing the application's view
of its environment as a library.
<p>
<hr>
<h2><a name=Ada>
Do you really recommend Ada over C++ for larger projects?</a></h2>
No. I have no idea who started that rumor, but it must have been
an over-enthusiastic or malicious Ada devotee.
<p>
<hr>
<h2><a name=compare>
Would you compare C++ to "some language"?</a></h2>
No, sorry, I won't.
You can find the reason in the introductory notes of
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a>:
<p>
"Several reviewers asked me to compare C++ to other languages.
This I have decided against doing.
Thereby, I have reaffirmed a long-standing and strongly held view:
Language comparisons are rarely meaningful and even less often fair.
A good comparison of major programming languages requires
more effort than most people are willing to spend,
experience in a wide range of application areas,
a rigid maintenance of a detached and impartial point of view,
and a sense of fairness.
I do not have the time, and as the designer of C++, my impartiality
would never be fully credible.
<p>
I also worry about a phenomenon I have repeatedly observed in
honest attempts at language comparisons.
The authors try hard to be impartial, but are hopelessly biased by
focusing on a single application, a single style of programming, or
a single culture among programmers.
Worse, when one language is significantly better known than others,
a subtle shift in perspective occurs: Flaws in the well-known language
are deemed minor and simple workarounds are presented, whereas similar
flaws in other languages are deemed fundamental.
Often, the workarounds commonly used in the
less-well-known languages are simply unknown to the people doing the
comparison
or deemed unsatisfactory because they would be unworkable in the more
familiar
language.
<p>
Similarly, information about the well-known language tends to be
completely
up-to-date, whereas for the less-known language, the authors rely on
several-year-old information.
For languages that are worth comparing, a comparison of language X as
defined
three years ago vs. language Y as it appears in the latest experimental
implementation is neither fair nor informative.
Thus, I restrict my comments about languages other than C++ to
<a href=#advanced>generalities</a>
and to very specific comments."
<p>
That said, I consider C++ the best choice in programming language for a
wide
variety of people and applications.
<p>
<hr>
<h2><a name=Others-do-compare>
Others do compare their languages to C++; doesn't that annoy you?</a></h2>
It does when it is done incompetently or for commercial gain.
The most widely circulated comparisons tend to be
those written by proponents of some language, Z, to prove that Z is
better
that other languages.
Given its wide use, C++ is often top of the list of languages
that the proponents of Z wants to prove inferior.
Often, such papers are "published" or distributed by a company that
sells Z as part of a marketing campaign.
Surprisingly, many seem to take an unreviewed paper written by people
working for a company selling Z "proving" that Z is best seriously.
One problem is that there are always grains of truth in such
comparisons.
After all, no language is better than every other in all possible ways.
C++ certainly isn't perfect,
but selective truth can be most seductive and occasionally completely
misleading.
<p>
When looking at a language comparison consider who wrote it,
consider carefully if the descriptions are factual and fair,
and also if the comparison criteria are themselves fair for all
languages considered.
This is not easy.
<p>
<hr>
<h2><a name=diatribes>
You won't compare C++ to other languages, but you write diatribes about C++?</a></h2>
I don't write diatribes (that's a hostile characterization of some
text), but
I do consider it reasonable - possibly even a duty - for someone who
designed a
language to explain its virtues and defend it against hostile
characterizations.
See
<a href=https://www.stroustrup.com/papers.html>my publications list</a>.
In paticular, see my extensive and peer reviewed papers for the
ACM History of Programming Conference:
<ul>
<li>B. Stroustrup:
<a href=https://www.stroustrup.com/hopl2.pdf>A History of C++: 1979-1991</a>.
ACM HOPL-ii. 1993.
<li>B. Stroustrup:
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>Evolving a language in and for the real world: C++ 1991-2006</a>.
ACM HOPL-III. 2007.
<li>B. Stroustrup:
 <a href=https://dl.acm.org/doi/pdf/10.1145/3386320>Thriving in a Crowded and Changing World: C++ 2006-2020</a>.
</ul>
Often, I also point out the limitations of C++ and the fundamental
assumptions
of the design of C++ (for example, see <a href=https://www.stroustrup.com/dne.html>D&amp;E</a>).
<p>
<hr>
<h2><a name=C-is-better>
C is better than C++ for small projects, right?</a></h2>
Not in my opinion. I never saw a project for which C was better than
C++ for any reason but the lack of a good C++ compiler.
<p>
<hr>
<h2><a name=C-is-subset>
Is C a subset of C++?</a></h2>
In the strict mathematical sense, C isn't a subset of C++.
There are programs that are valid C but not valid C++ and even
a few ways of writing code that has a different meaning in C and C++.
However, C++ supports every programming technique supported by C.
Every C program can be written in essentially the same
way in C++ with the same run-time and space efficiency.
It is not uncommon to be able to convert tens of thousands of lines
of ANSI C to C-style C++ in a few hours.
Thus, C++ is as much a superset of ANSI C as ANSI C is a superset
of K&amp;R C and much as ISO C++ is a superset of C++ as it existed in 1985.
<p>
Well written C tends to be legal C++ also. For example, every example
in Kernighan &amp; Ritchie: "The C Programming Language (2nd Edition)" is
also a C++ program.
<p>
Examples of C/C++ compatibility problems:
<pre>	int main()
	{
		double sq2 = sqrt(2);   /* Not C++: call undeclared function */
		int s = sizeof('a');    /* silent difference: 1 in C++ sizeof(int) in C */
	}
</pre>
Calling an undeclared function is poor style in C and illegal in C++.
So is passing arguments to a function using a declaration that doesn't list
argument types:
<pre>	void f();	/* argument types not mentioned */

	void g()
	{
		f(2);	/* poor style C. Not C++ */
	}
</pre>
In C, a void* can be implicitly converted to any pointer type, and free-store
allocation is typically done using malloc() which has no way of checking
if "enough" memory is requested:
<pre>	void* malloc(size_t);

	void f(int n)
	{
		int* p = malloc(n*sizeof(char));  /* not C++. In C++, allocate using `new' */
		char c;
		void* pv = &amp;c;
		int* pi = pv;   /* implicit conversion of void* to int*. Not in C++ */
	}
</pre>
Note the potential alignment error caused by the implicit conversion
of the void* to a int*.
See
<a href=https://www.stroustrup.com/bs_faq2.html#void-ptr>the C++ alternative to void* and malloc()</a>.
<p>
When converting from C to C++, beware that C++ has more keywords than C:
<pre>	int class = 2;    /* ok in C. Syntax error in C++ */
	int virtual = 3;  /* ok in C. Syntax error in C++ */
</pre>
Except for a few examples such as the ones shown above
(and listed in detail in the C++ standard and in Appendix B of
<a href=https://www.stroustrup.com/3rd.html>The C++ Programming Language (3rd Edition)</a>),
C++ is a superset of C.
(Appendix B is available for downloading).
<p>
Please note that "C" in the paragraphs above refers to Classic C and C89.
C++ is not a descendant of C99; C++ and C99 are siblings.
C99 introduces several
<a href=#merge>novel opportunities for C/C++ incompatibilities</a>.
<p>
<hr>
<a name=difference>
<h2>What is the difference between C and C++?</h2>
</a><p><a name=difference>
C++ is a direct descendant of C that retains almost all of C as a subset.
C++ provides stronger type checking than C and directly supports a wider
range of programming styles than C.
C++ is "a better C" in the sense that it supports the styles of programming
done using C with better type checking and more notational support (without
loss of efficiency).
In the same sense, ANSI C is a better C than K&amp;R C.
In addition, C++ supports data abstraction, object-oriented programming,
and generic programming
(see </a><a href=https://www.stroustrup.com/books.html>my books</a>).
<p>
I have never seen a program that could be expressed better in C than in C++
(and I don't think such a program could exist - every construct in C has an
obvious C++ equivalent).
However, there still exist a few environments where the support for C++
is so weak that there is an advantage to using C instead.
There aren't all that many of those left, though; see
<a href=https://www.stroustrup.com/compilers.html>my (incomplete) compilers list</a>.
<p>
For a discussion of the design of C++ including a discussion of its
relationship with C see
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a>.
<p>
Please note that "C" in the paragraphs above refers to Classic C and C89.
C++ is not a descendant of C99; C++ and C99 are siblings.
C99 introduces several
<a href=#merge>novel opportunities for C/C++ incompatibilities</a>.
Here is a description of the 
<a href=http://david.tribble.com/text/cdiffs.htm>differences between C++98 and C99</a>.
<p>
<hr>
<h2><a name=merge>
Do you really think that C and C++ could be merged into a single language?</a></h2>
I think that it would be a very good thing for the C/C++ community if they
were. That is, if the C/C++ incompatibilities were systematically and
completely eliminated and that future evolution was organized so as to
prevent new incompatibilities from emerging.
Whether that's possible is another matter.
<p>
My basic point is that the current C/C++ incompatibilities are "accidents of
history" that have no fundamental reasons behind them (though they all
"looked like a good idea at the time" to some competent and well-meaning
people).
The C/C++ incompatibilities provide no benefits to the community at large,
cause serious problems to a large section of the C/C++ community,
and could - with great difficulty - be eliminated.
<p>
For a far more detailed presentation of my views on C/C++ compatibility, see
the series of papers I wrote about this:
<ul>
<li>
B. Stroustrup:
<a href=https://www.stroustrup.com/examples_short.pdf>C and C++: Case Studies in Compatibility</a>.
The C/C++ Users Journal.
September 2002.
<li>
B. Stroustrup:
<a href=https://www.stroustrup.com/compat_short.pdf>C and C++: A Case for Compatibility</a>.
The C/C++ Users Journal.
August 2002.
<li>
B. Stroustrup:
<a href=https://www.stroustrup.com/siblings_short.pdf>C and C++: Siblings</a>.
The C/C++ Users Journal.
July 2002.
<li>
B. Stroustrup:
<a href=https://www.stroustrup.com/sibling_rivalry.pdf>Sibling rivalry: C and C++</a>.
AT&amp;T Labs - Research Technical Report. TD-54MQZY.
January 2002.
</ul>
I imagine that if incompatibilities were eliminated (by making changes to
both C and C++), there would still be entities called C and C++, but then
<a href=#C-is-subset>C really would be defined as a subset of C++</a>.
<p>
Please note that these papers were written in late 2001 and early 2002 when it was still possible
to imagine coordinated action by the C and C++ standards committees leading to practical results by
the end of the decade. This didn't happen.
<p>
<hr>
<h2><a name=whyC>
Why did you make C++ (almost) compatible with C?</a></h2>
I wanted C++ to be compatible with a complete language with sufficient performance and
flexibility for even the most demanding systems programming.
I had a perfect dread of producing yet-another pretty language with unintentional limitations.
See Section 2.7 of 
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a>
for historical details and read the articles in
<a href=#merge>Do you really think ...?</a>
for a (retrospective) technical discussion of C/C++ compatibility issues.
<p>
At the time, I considered C the best systems programming language available.
That was not as obvious then (1979) as it later became,
but I had experts such as
<a href=http://netlib.bell-labs.com/who/dmr>Dennis Ritchie</a>,
Steve Johnson,
<a href=http://www.fraserresearch.org/agf.html>Sandy Fraser</a>,
Greg Chesson,
<a href=http://www.cs.dartmouth.edu/~doug>Doug McIlroy</a>, and
<a href=http://www.cs.princeton.edu/~bwk/>Brian Kernighan</a>
down the corridor from whom I could learn and get feedback.
Without their help and advice, and without C, C++ would have been stillborn.
<p>
Contrary to repeated rumors,
I was never told that I had to use C; nor was I ever told not to use C.
In fact, the first C++ manual grew from troff source of the C manual that Dennis gave me.
Many new languages were designed at Bell labs; in "Research" at least, there were no
rules enforcing language bigotry.
<p>
<hr>
<h2><a name=C-slash>
What do you think of C/C++?</a></h2>
No that's not really a question I often get. In that sense, it is the 
only "fake FAQ" in this FAQ. However, it ought to be a FAQ because people 
use "C/C++" as if it meant something specific and as if they knew what 
it meant, leading to much confusion and misery. People should ask "What 
is C/C++?" and then on reflection stop using the term. It does harm.
<p>
There is no language called "C/C++".
The phrase is usually used by people who don't
have a clue about programming (e.g. HR personnel and poor managers).
Alternatively, it's used by people who simple do not know C++ (and often not C either).
When used by programmers,
it typically indicates a "C++ is C with a few useful and a lot of useless complicated features added"
attitude.
Often, that is the point of view of people who like to write their own strings and hash tables with
little knowledge of the standard library beyond printf and memcpy. 
There are people who stick to a restricted subset of C++ for perfectly good reasons,
but they (as far as I have noticed) are not the people who say "C/C++".
<p>
I use C/C++ only in phrases such as "C/C++ compatibility" and "C/C++ community". 
<p>
<hr>
<h2><a name=invention>
When was C++ invented?</a></h2>
I started work on what became C++ in 1979.
The initial version was called "C with Classes".
The first version of C++ was used internally in AT&amp;T in August 1983.
The name "C++" was used late that year.
The first commercial implementation was released October 1985 at the same time
as the publication of
<a href=https://www.stroustrup.com/1st.html>the 1st edition of The C++ Programming Language</a>.
Templates and exception handling were included later in the 1980's
and documented in 
<a href=https://www.stroustrup.com/arm.html>The Annotated C++ Reference Manual</a>
and
<a href=https://www.stroustrup.com/2nd.html>The C++ Programming Language (2rd Edition)</a>.
The first ISO C++ standard was C++98 as described in <a href=https://www.stroustrup.com/3rd.html>The C++ Programming Language (3rd Edition)</a>.
<p>
The current definition of C++ The 2011 ISO C++ Standard described in
<a href=https://www.stroustrup.com/4th.html>The C++ Programming Language (4th Edition)</a>.
<p>
You can find a more complete timeline and more detailed explanations in
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a> and 
<a href=https://www.stroustrup.com/hopl2.pdf>A History of C++: 1979-1991</a> and 
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>Evolving a language in and for the real world: C++ 1991-2006</a>.
<p>
<hr>
<h2><a name=why>
Why did you invent C++?</a></h2>
I wanted to write efficient systems programs in the styles encouraged by
Simula67.
To do that, I added facilities for better type checking, data abstraction,
and object-oriented programming to C.
The more general aim was to design a language in which I could write programs
that were both efficient and elegant.
Many languages force you to choose between those two alternatives.
<p>
The specific tasks that caused me to start designing and implementing C++
(initially called "C with Classes") had to do with distributing
operating system facilities across a network.
<p>
You can find more detailed explanations in
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a>.
See also
<a href=https://www.stroustrup.com/hopl2.pdf>A History of C++: 1979-1991</a> and
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>Evolving a language in and for the real world: C++ 1991-2006</a>.
<p>
<hr>
<h2><a name=why-ATT>
Why did AT&amp;T support the development of C++?</a></h2>
When I first developed C++, AT&amp;T built systems of greater complexity and with greater reliability
requirements than most organizations.
Consequently, we had to influence the market
and help set standards that meet our needs - or else we wouldn't have the
tools to build our systems. Left to itself "the industry" will create
languages and tools for dealing with "average" problems. Similarly,
teachers tend to focus on languages and tools that serve students and
researchers well - even if they don't scale to the most demanding tasks.
<p>
At the time when I developed C++ - and before that when Ken Thompson and
Dennis Ritchie developed Unix and C - AT&amp;T was probably the worlds largest
civilian user of (and consumer of) software tools. Then, we probably used
a wider
range of systems - from the tiniest embedded processors to the largest
supercomputers and data-processing systems. That put a premium on systems
that were applicable in many technical cultures and on many platforms.
C and C++ were designed with such demands in mind.
<p>
Thus generality is essential, and proprietary features are seen as limiting
the choice of platforms and vendors. As a consequence AT&amp;T was and is a major
supporter of formal standards (for example, ISO C and ISO C++).
<p>
Actually, AT&amp;T made enough money on Cfront, my original C++ compiler,
to pay for the development of C++ several times over.
<p>
<hr>
<h2><a name=revenues>
Do you own C++?</a></h2>
No. If anyone "owns C++," it must be the ISO. AT&amp;T gave the rights to the
C++ manual that I wrote to the ISO.
<a href=https://www.stroustrup.com/iso_pressrelease2.html>The ISO C++ Standard</a>
is copyrighted by ISO.
<p>
Compiler vendors do not pay royalties to me or to AT&amp;T for C++, and ISO
standards are specifications intended for royalty-free use by everyone
(once they have paid the ISO or a national standard committee for their
copy of the standard).
The individual compilers are owned by their respective vendors/suppliers.
<p>
"But someone from SCO claimed that they own C++"; is that not so? It's complete rubbish.
I saw that interview. The SCO guy clearly had no clue what C++ was, referring to it as
"the C++ languages".
At most, SCO may own a 15-year old and seriously outdated version of Cfront - my original
C++ compiler. I was careful not to patent or trademark anything to do with C++. That's one
reason we write plain "C++" and not "C++(tm)".
The C++ standard is unencumbered of patents - the committee carefully checked that also.
<p>
<hr>
<h2><a name=name>
Where did the name "C++" come from?</a></h2>
Chapter 3 of
<a href=https://www.stroustrup.com/dne.html>D&amp;E</a>:
``I picked C++ because it was short, had nice interpretations, and wasn't of
the form "adjective C."'
In C, ++ can, depending on context, be read as "next," "successor," or 
"increment," though it is always pronounced "plus plus."
The name C++ and its runner up ++C are fertile sources for jokes and puns
-- almost all of which were known and appreciated before the name was chosen.
The name C++ was suggested by Rick Mascitti.
It was first used in December of 1983 when it was edited into the final
copies of [Stroustrup,1984] and [Stroustrup,1984c].
<p>
Chapter 1 of
<a href=https://www.stroustrup.com/4th.html>TC++PL</a>:
``The name C++ (pronounced "see plus plus") was coined by Rick Mascitti in the summer of 1983.
The name signifies the evolutionary nature of the changes from C; "++" is the C increment
operator. The slightly shorter name "C+" is a syntax error; it has also been 
used as the name of an
unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The 
language is not
called D, because it is an extension of C, and it does not attempt to remedy 
problems by removing
features. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].''
<p>
The ``C'' in C++ has a long history.
Naturally, it is the name of the language Dennis Ritchie designed.
C's immediate ancestor was an interpreted descendant
of BCPL called B designed by Ken Thompson.
BCPL was designed and implemented by Martin Richards from Cambridge University
while visiting MIT in the other Cambridge.
BCPL in turn was Basic CPL, where CPL is the name of a rather large (for its time)
and elegant programming language developed jointly by the universities of
Cambridge and London.
Before the London people joined the project "C" stood for Cambridge.
Later, "C" officially stood for Combined.
Unofficially,
"C" stood for Christopher because Christopher Strachey was the main power 
behind CPL.''
<p>
<hr>
<h2><a name=bootstrapping>
Which language did you use to write C++?</a></h2>
The first C++ compiler (Cfront) was written in C++.
To build that, I first used C to write a ``C with Classes''-to-C preprocessor.
``C with Classes'' was a C dialect that became the immediate ancestor to C++.
That preprocessor translated "C with Classes" constructs (such as classes
and constructors) into C.
It was a traditional preprocessor that didn't understand all of the
language, left most of the type checking for the C compiler to do,
and translated individual
constructs without complete knowledge. 
I then wrote the first version of Cfront in "C with Classes".
<p>
Cfront was a traditional compiler that did complete syntax and semantic
checking of the C++ source.
For that, it had a complete parser, built symbol tables, and built a complete
internal tree representation of each class, function, etc.
It also did some source level optimization on its internal tree representation
of C++ constructs before outputting C.
The version that generated C, did not rely on C for any type checking.
It simply used C as an assembler.
The resulting code was uncompromisingly fast.
For more information, see <a href=https://www.stroustrup.com/dne.html>D&amp;E</a>.
<p>
<hr>
<h2><a name=understand>Did you really not understand what you were doing?</a></h2>
This one seems very popular. Or rather, it seems to be popular to assert that I had no clue so that C++'s success is some kind of accident.
Yes, such statements annoy me, because they dismiss my work over decades and the hard work of many of my friends.
<p>
Let's first be perfectly clear: No, I did not anticipate the run-away success of C++ and no, I did not foresee every technique used with C++ or every application of C++. Of course not!
<p>
However, statements like these are very misleading:
<ul>
<li>Bjarne doesn't understand C++!
<li>Bjarne didn't anticipate RAII and deterministic destruction!
<li>Bjarne didn't anticipate template-metaprogramming! 
</ul>
<p>
This FAQ was prompted by seeing these and several more of their ilk today.
<p>
I did outline the criteria for the design and implementation of C++.
I did explicitly aim for generality: "I'm not interested in a language that can only do what I can imagine" and for efficiency "a facility must not just be useful, it must be affordable."
I suggest that doubters read <a href=https://www.stroustrup.com/DnE.html>The Design and Evolution of C++</a> and my <a href=https://www.stroustrup.com/hopl2.pdf>HOPL2</a> and <a href=https://www.stroustrup.com/hopl-almost-final.pdf>HOPL3</a> papers (these are peer-reviewed papers).
As for deterministic destruction, it was in "C with Classes" in the first week or two (1979).
I held back the introduction of exceptions into C++ for half a year until I discovered RAII (1988).
RAII is an integral and necessary part of the C++ exception mechanism.
<p>
I was very surprised when Jeremy Siek first showed me the compile-time <b>if</b> that later became <b>std::conditional</b>, but I had aimed for generalty (and gotten Turing completeness modulo translation limits).
I opposed restrictions to C++ immediately when Erwin Unruh presented what is widely believed to be the first template metaprogram to the ISO Standards committee's evolution working group. To kill template-metaprogramming, all I would have had to do was to say nothing. Instead my comment was along the lines "Wow, that's neat! We mustn't compromise it. It might prove useful."
Like all powerful ideas, template-metaprogramming can be misused and overused, but that does not imply that the fundamental idea of compile-time computation is bad.
And like all powerfuls ideas, the implications and techniques emerged over time with contributions from many individuals.
<p>
There is more to scolarship than a look at the wikipedia, a quick Google-search, and a couple of blog posts.
There is more to invention than giving a simple list of implications. Fundamental principles and design guidelines are essential.
My part of the C++ design opened the possibility for <i>many</i> to contribute, and if you look at my writings and postings, you see that I try hard to give credit (e.g., see the reference sections of
<a href=https://www.stroustrup.com/C++11FAQ.html>my C++11 FAQ</a>) or the history sections of <a href=https://www.stroustrup.com/books.html>my books</a>.
<p>
And no, I'm not a walking C++ dictionary.
I do not keep every technical detail in my head at all times.
If I did that, I would be a much poorer programmer.
I do keep the main points straight in my head most of the time, and I do know where to find the details when I need them.
For example:
<ul>
<li><a href=https://www.stroustrup.com/4th.html>TC++PL</a> 
<li><a href=http://www.open-std.org/jtc1/sc22/wg21>the ISO C++ committee's home pages</a>.
<li><a href=http://www.isocpp.org/>isocpp.org</a>.
</ul>
<hr>
<h2><a name=garbage-collection>
Why doesn't C++ have garbage collection?</a></h2>
If you want automatic garbage collection, there are good commercial and
public-domain garbage collectors for C++.
For applications where garbage collection is suitable, C++ is an
excellent
garbage collected language with a performance that compares favorably
with
other garbage collected languages.
See <a href=https://www.stroustrup.com/4th.html>The C++ Programming Language</a>
for
a discussion of automatic garbage collection in C++.
See also, Hans-J. Boehm's
<a href=http://www.hpl.hp.com/personal/Hans_Boehm/gc>site for C and C++ garbage collection</a>.
<p>
Also, C++ supports programming techniques that allows memory management to
be <a href=https://www.stroustrup.com/bs_faq2.html#memory-leaks>safe and implicit without a garbage collector</a>.
I consider garbage collection a last choice and an imperfect way of handling for resource management.
That does not mean that it is never useful, just hat there are better approaches in many situations.
<p>
<a href=https://www.stroustrup.com/C++11FAQ.html>C++11</a> offers a GC ABI.
<p>
<p>I don't like garbage.
I don't like littering.
My ideal is to eliminate the need for a garbage colletor by not producting any garbage.
That is now possible.
Tools supporting and enforcing the programming techniques that achieves that are being produced.
For an overview, see
<a href=http://www.stroustrup.com/resource-model.pdf>A brief introduction to C++'s model for type- and resource-safety.</a>.
<hr>
<h2><a name=gui>
Why doesn't C++ have a GUI?</a></h2>
C++ has many commercial and open source GUIs (e.g.
<a href=http://gtkmm.sourceforge.net/>Gtkmm</a>,
<a href=http://smartwin.sourceforge.net/>SmartWin++</a>,
<a href=http://www.objectcentral.com/>V C++ GUI</a>,
<a href=http://www.fltk.org/>FLTK</a>, and
<a href=http://qt-project.org/>Qt</a>).
In particular, every platform vendor provides a C++ library to access their GUI.
The problem is that it doesn't have a standard GUI, and that is indeed a major problem.
<p>
Note that providing a GUI is both a technical and political problem.
There are lots of GUIs with lots of users, and generally they wouldn't like some other
GUI to be declared standard.
Anyway, the standards committee do not have the resources to build a new and better GUI.
<p>
<hr>
<h2><a name=threads>
Why doesn't C++ support threads?</a></h2>
<a href=https://www.stroustrup.com/C++11FAQ.html>C++11</a> offers threads.
<p>
<hr>
<h2><a name=decline>
Is C++ in decline?</a></h2>
No, I don't think so.
C++ use appears to be declining in some areas and to be on an upswing in others.
If I had to guess, I'd suspect a net decrease sometime during 2002-2004 and a net 
increase in 2005-2007 and again in 2010-2011, but I doubt anyone really knows. Most of the 
popular measures basically measures noise and ought to report their 
findings in decibel rather than "popularity." 
A professional survey in 2015 estimated
<a href=http://blog.jetbrains.com/clion/2015/07/infographics-cpp-facts-before-clion/>the number of C++ programmers</a>
to be 4.4 million.
Many of the major uses of C++ are 
in infrastructure (telecommunications, banking, embedded systems, etc.) 
where programmers don't go to conferences or describe their code in 
public. Many of the most interesting and important C++ applications are 
not noticed, they are not for sale to the public as programming 
products, and their implementation language is never mentioned. Examples 
are Google and "800" phone numbers. Had I thought of a "C++ inside" logo 
in 1985, the programming world might have been different today.
<p>
One simple thing that confuses many discussions of language 
use/popularity is the distinction between relative and absolute 
measures. For example, I say (in 2011) that C++ use is growing when I see user 
population grow by 200,000 programmers from 3.1M to 3.3M. However, 
somebody else may claim that "C++ is dying" because it's "popularity" 
has dropped from 16 percent to 11 percent of the total number of programmers. 
Both claims could be simultaneously true as the number of programmers 
continues to grow and especially as what is considered to be programming 
continues to change. I think that C++ is more than holding its own in 
its traditional core domains, such as infrastructure, systems 
programming, embedded systems, and applications with serious time and/or 
space and/or
power consumption constraints.
See also <a href=http://www.devx.com/SpecialReports/Article/38813/0/page/6>my DevX interview</a>.
<p>
<hr>
<h2><a name=improve>
What's being done to improve C++?</a></h2>
Implementers are continually improving their <a href=https://www.stroustrup.com/compilers.html>compilers</a>,
libraries, and tools.
The last five years have seen very significant improvements in quality.
This is what most directly and most immediatly helps people;
that, and the host of proprietary and open source libraries and tools that are continuously
being produced by the C++ community. See <a href=https://www.stroustrup.com/C++.html>my C++ page</a> for examples.
<p>
The <a href=https://www.stroustrup.com/C++.html>first ISO C++ standard</a> was ratified in 1998.
The next version <a href=https://www.stroustrup.com/C++11FAQ.html>C++11</a>,
is complete and shipping.
You can find papers describing C++11 on <a href=https://www.stroustrup.com/papers.html>my publications page</a>
and all documents relating to the new standard on
<a href=http://www.open-std.org/jtc1/sc22/wg21>the ISO C++ committee's home pages</a>.
My <a href=https://www.stroustrup.com/hopl-almost-final.pdf>HOPL-iii paper</a> on the last 15 years of C++ evolution
may the best explanation of what is being done and why.
A <a href=http://www.devx.com/SpecialReports/Article/38813/0/page/1>recent interview</a>
contains lists of new language features and standard libraries.
<p>
When considering the evolution of C++, it is worth remembering that the aim is not to add the largest
number of new features, but to improve C++ for its key application domains, including systems
programming and library building, without breaking older code
(there are billions of lines of C++ "out there").
<p>
<hr>
<h2><a name=Hello-world>
Why is the code generated for the "Hello world" program ten times larger for C++
than for C?</a></h2>
It isn't on my machine, and it shouldn't be on yours.
I have even seen the C++ version of the "hello world"
program smaller than the C version.
In 2004, I tested using gcc -O2 on a Unix and
the two versions (iostreams and stdio) yielded identical sizes.
There is no language reason why the one version should be larger than
the other. It is all an issue on how an implementor organizes the
standard libraries (e.g. static linking vs. dynamic linking,
locale support by default vs. locale support enabled through and option, etc.).
If one version is significantly larger than the other,
report the problem to the implementor of the larger.
<p>
<hr>
<h2><a name=advanced>
How can a legacy language like C++ compete with modern, advanced languages?</a></h2>
Naturally, calling C++ a legacy language shows a bias (see
<a href=#legacy>legacy code</a>).
That aside, people are usually thinking of
<a href=#Java>Java</a> or <a href=#Csharp>C#</a> when they ask such a
question.
I will not <a href=#compare>compare C++ to those languages</a>, but I can
point out that "modern" doesn't necessarily mean "better", and that both
Java and C# are rooted in 1980s style OOP to an even greater extent than
early C++ is.
<p>
Since 1987 or so, the focus of development the C++ language and its associated
programming styles have been the use
of templates, static polymorphism, generic programming, and multiparadigm
programming. This is way beyond the scope of the much-hyped proprietary
languages. Another key difference is that C++ supports user-defined types
to the same extent as built-in types. This - especially in
combination with the use of templates, constructors, and destructors -
enables the C++ programmer to use
programming and design techniques that (IMO) are more advanced than what is
supported in the languages with which C++ is most often compared; e.g. see
<a href=https://www.stroustrup.com/bs_faq2.html#finally>RAII</a>.
<p>
Standard C++ and the design and programming styles it supports owe a debt
to the functional languages, especially to ML.
Early variants of ML's type deduction mechanisms were (together with much
else) part of the inspiration
of templates. Some of the more effective functional programming
techniques were part of the inspiration of the STL and the use of function
objects in C++.
On the other hand, the functional community missed the boat with
object-oriented programming, and few of the languages and tools from that
community benefited from the maturing experience of large-scale industrial
use.
<p>
Clearly, I don't think that
<a href=#garbage-collection>garbage collection</a> is the sole defining
characteristic of "advanced" in the context of programming languages.
In particular, note that C++ provides support for effective and efficient
memory management techniques that can eliminate resource leaks without the
use of a garbage collector.
If you disagree, you can just start using a garbage collector for C++;
there are good ones available.
<p>
<hr>
<h2><a name=multiparadigm>
What is "multiparadigm programming"?</a></h2>
Multiparadigm programming is a fancy way of saying ``programming using more
than one programming style, each to its best effect.''
For example, using object-oriented programming when run-time resolution
between different object types is required and generic programming when
static type safety and run-time performance is at a premium.
Naturally, the main strength of multiparadigm programming is in programs
where more than one paradigm
(programming style) is used, so that it would be hard to get the same effect
by composing a system out of parts written in languages supporting different paradigms.
I find the most compelling cases for multiparadigm programming are found where
techniques from different paradigms are used in close collaboration to
write code that is more elegant and more maintainable than would be possible
within a single paradigm.
A simple example is the traversal of a statically typed container of objects
of a polymorphic type:
<pre>	void draw_all(vector&lt;Shape*&gt;&amp; vs)	// draw each element of a standard vector
	{
		for_each(vs.begin(),vs.end(),[](Shape* p){ p-&gt;draw(); });
	}
</pre>
Here, Shape will be an abstract base class defining the interface to
a hierarchy of geometric shapes.
This example easily generalizes to any standard library container:
<pre>	template&lt;class C&gt;
	void draw_all(C&amp; cs)	// draw each element of a standard container
	{
		for_each(cs.begin(),cs.end(),[](Shape* p){ p-&gt;draw(); });
	}
</pre>
<p>
Jim Coplien's book "Multiparadigm Design for C++" (Addison Wesley, 1998)
explores the use of multiple paradigms in the context of design
and design methods. 
<p>
We need a better -- more descriptive -- term to replace ``multi-paradigm.''
<hr>
<h2><a name=big>
Why is C++ so BIG?</a></h2>
C++ isn't as big as some people imagine.
It's not a tiny language designed to be a minimal language for teaching,
but neither are the languages people most often compare it to, such as C, Java, C#.
They too are huge compared to say, Pascal as Dr. Wirth originally defined it
- for good reasons, I think.
The programming world is far more complex today than it was 30 years ago,
and modern programming languages reflect that.
<p>
The C++ standard is 1151 pages; that includes 430 pages of language definition and 770 pages of standard-library description.
The size of the language definition is within 5% of the language descriptions of Java and C# (measured by page count).
Similarly,
<a href=https://www.stroustrup.com/4th.html>TC++PL</a> is 1360 pages; of those 750 of those are devoted to language facilities and programming techniques; the rest discuss libraries, etc.
<p>
C++ directly supports (i.e., in the language) what some other languages support through libraries,
so the language part will be relatively larger. On the other hand, if you want to write
a "typical modern application", you need to consider operating system interfaces, GUI,
databases, web interfaces, etc. the sum of language features, libraries, and programming
conventions and standards that you must become familiar with dwarf the programming language.
Here, C++'s size can be an advantage as far as it better supports good libraries.
<p>
Finally, the days where a novice programmer can know all of a language are gone, at least for the
languages in widespread industrial use. Few people know "all of C" or "all of Java" either and none
of those are novices. It follows that nobody should have to apologize for the fact that
novices do not know all of C++. What you must do - in any language - is to pick a subset,
get working writing code, and gradually learn more of the language, its libraries, and its tools.
For my suggestion on how beginners can approach C++, see
<a href=https://www.stroustrup.com/programming.html>Programming: Principles and Practice using C++</a>.
<p>
<hr>
<h2><a name=EC++>
What do you think of EC++?</a></h2>
EC++ is an (almost) subset of C++ lacking exceptions, templates,
namespaces,
RTTI support, multiple inheritance, etc. being defined by an "industry
consortium."
I am not in favor of language subsets or dialects.
I am especially not fond of subsets that cannot support the standard
library so
that the users of that subset must invent their own incompatible
foundation libraries.
I fear that a defined subset of C++ could split the user community and
cause acrimony (3/31/1999: I just saw an advertisement that used vivid
graphics to indicate how EC++ reduced "fat" (i.e. memory space) by abolishing
- among other things - namespaces, templates, and C++ standard strings. Sigh!).
I strongly prefer work on "standards" to occur in an open forum (such
as ISO or a national standards organization).
<p>
For a discussion of how embedded systems implementers can
address performance issues using Standard C++ (better than by using dialects)
see the ISO C++ committee's <a href=https://www.stroustrup.com/performanceTR.pdf>report on performance</a>.
To the best of my knowledge EC++ is dead (2004), and if it isn't it ought to be.
<p>
For a look at how ISO C++ can be used for serious embedded systems programming, see
<a href=https://www.stroustrup.com/JSF-AV-rules.pdf>the JSF air vehicle C++ coding standards</a>.
<p>
<hr>
<h2><a name=from-Smalltalk>
C++ got its Object-Oriented concepts from Smalltalk?</a></h2>
No. C++ got the key notions of classes, derived classes, virtual
functions
(in other words, the notions of encapsulation, inheritance and
polymorphism)
from Simula just like Smalltalk did.
In terms of family relationships, C++ and Smalltalk are siblings.
<p>
<hr>
<h2><a name=Object-Oriented-language>
Is C++ an Object-Oriented language?</a></h2>
C++ is a
<a href=#multiparadigm>multi-paradigm programming language</a>
that supports Object-Oriented and other useful styles of programming.
If what you are looking for is something that forces you to do things
in
exactly one way, C++ isn't it.
There is no one right way to write every program - and even if there
were
there would be no way of forcing programmers to use it.
<p>
That said, writing C-style programs in C++ is for most applications not
an
optimal use of C++. To be a really effective C++ programmer, you must
use
the abstraction mechanisms and the type system in a way that fits
reasonably
with their intent. Trying to ignore or defeat the C++ type system is a
most frustrating experience.
<p>
Writing Java-style code in C++ can be as frustrating and
sub-optimal as
writing C-style code in C++.
<p>
For a more detailed discussion see any of my overview or style papers
from my
<a href=https://www.stroustrup.com/papers.html>bibliography</a>.
In particular, see my OOPSLA paper "Why C++ isn't just an Object-Oriented Programming Language".
<p>
 
<hr>
<h2><a name=really-say-that>
Did you really say that?</a></h2>
See <a href="https://www.stroustrup.com/quotes.html%3EQuotes%3C/a%3E.%3Chr%3E%3Ch2%3E%3Ca%20name=">
Did you really give an interview to IEEE?</a>
in which you confessed that C++ was deliberately created as an awful
language
for writing unmaintainable code to increase programmers' salaries?
<p>
Of course not. Read <a href=https://www.stroustrup.com/ieee_interview.html>the real IEEE interview</a>.
<p>
<hr>
<h2><a name=legacy>
What is "legacy code"?</a></h2>
"Legacy code" is a term often used derogatorily to characterize code that
is written in a language or style that
(1) the speaker/writer consider outdated
and/or
(2) is competing with something sold/promoted by the speaker/writer.
"Legacy code" often differs from its suggested alternative by actually
working and scaling.
<p>
<hr>
<h2><a name=number-of-C++-users>
Is the number of C++ users still doubling every year?</a></h2>
No. During 1980-1991, the number of users doubled every seven
and a half months (see
<a href=https://www.stroustrup.com/dne.html> The Design and Evolution of C++</a>).
However, there simply aren't enough programmers to sustain that.
From the few numbers I can get (compiler sales, book sales, workloads of
consultants I happen to know, IDC, etc.), I estimate that the growth rate is
a few percent.
<a href=#decline>Steady and definitely positive</a>.
IDC estimated that 1.2 million C++ Implementations were sold in 1996.
Their 2001 estimate of the number of C++ programmers was "about 3 million";
their 2004 number was "more than 3 million".
A
<a href=http://blog.jetbrains.com/clion/2015/07/infographics-cpp-facts-before-clion/>2015 professional survey</a> found 4.4 million C++ programmers.
That seems plausible and indicates a continued growth.
<p>
<hr>
<h2><a name=use-C++>
Does anyone use C++ these days?</a></h2>
Yes, <a href=#number-of-C++-users>many</a> do. There are too many C++ users
to effectively count them, but the number is in the millions.
C++ is supported by all <a href=https://www.stroustrup.com/compilers.html>major vendors</a>.
For examples of C++ use see my <a href=https://www.stroustrup.com/applications.html> application sampler</a>.
<p>
<hr>
<h2><a name=use-C++-for-OS>
Why isn't C++ used for Operating Systems?</a></h2>
It is, and it has been for over a decade;
see <a href=https://www.stroustrup.com/applications.html>my list of C++ applications</a>.
A recent example is <a href=http://isocpp.org/blog/2013/09/startup-cloudius-announces-osv-a-new-c-open-source-vm-operating-system>Cloudius</a>.
<p>
<hr>
<h2><a name=C++success>
Did you expect C++ to become such a success?</a></h2>
Of course not.
The success rate for general-purpose programming languages is vanishingly small.
I knew that, and I knew that the chance of success was affected by marketing
clout, which I did not have.
<p>
C++ was initially designed and implemented as a set of general
facilities addressing some specific problems that I and my colleagues faced.
The generality - and efficiency - of the facilities provided turned out to
serve much wider needs than I had anticipated.
The emphasis on general facilities - as opposed to the provision of specific
solutions to specific problems - has remained with C++ and has served its
community well as the specific problems facing the community have changed
over the years.
<p>
<hr>
<h2><a name=certification>
What's a good certification for C++ programmers?</a></h2>
To the best of my knowledge, there isn't a good certification program for C++ programmers.
That's a pity. A <i>good</i> certification program would be most useful.
However, C++ lacks the central organization that would produce a solid certification program, and
a certification program without authority or that focused on syntax would be worse than useless.
<p>
<hr>
<h2><a name=morgan>Why did you go to work at Morgan Stanley?</a></h2>
I felt it was time to get back to industry.
I missed the challenges from
real-world, large-scale projects with real consequences in case of success
and failure.
Academia was beginning to feel a bit cushy and ``Ivory tower'' to me
(that is <b><i>not</i></b> the way academia is for younger faculty and adjunct faculty
-- those need and deserve far more support than they get).
Morgan Stanley's technology division has a huge range of computer science challenges, and a lot of clever, well-educated, and surprisingly (given the popuar reputation of people working for ``Wall Street'') nice people.
Morgan Stanley has a lot of serious C++ use.
In addition, I look after C++ standardization (C++17 is on its way) and do some research in my capacity of professor at
<a href=http://www.cs.columbia.edu/>Columbia University</a>
and
<a href=http://engineering.tamu.edu/cse/>Texas A&amp;M University</a>.
It was time to get back to the North-East and to my family there.
<p>
PS. I work for Morgan Stanley, not J.P. Morgan.
<a href=http://www.morganstanley.com/>Morgan Stanley</a> is a fairly
heavily-regulated <b>bank</b>, rather than a generic ``financial institution,''
and IMO one of the most ethically-run financial institutions.
<p>
PPS. You simply cannot run a modern society without banks.
<p>
<hr>
<h2><a name=tamu>Why did you go to work at Texas A&amp;M University?</a></h2>
The steam had run out of Bell Labs and its successors, AT&amp;T Labs and Lucent Bell Labs.
It just wasn't what it used to be.
I had (and have) friends at TAMU and thought it a good
place to learn the various skills of academic life.
For starters, academic
research is rather different from industrial research that I had been used to.
Smilarly, teaching freshmen and graduates is very different from teaching
professionals.
I also helped build up the
<a href=http://engineering.tamu.edu/cse/>Computer Science and Engineering Department</a>.
I am still associated with TAMU as a University Distinguished Professor.
<p>
PS. Texas A&amp;M University != University of Texas.
<p>
<hr>
<h2><a name=btl>Why did you go to work at Bell labs?</a></h2>
Because I could.
In the 1980s (and years before and after that), there was
no place on earth like it. There still isn't.
<a href=http://en.wikipedia.org/wiki/Bell_Labs>Bell Labs</a> was the premier applied
science and engineering research center in the world.
It was a most exciting
and challenging place to work, with extraordinary colleagues.
I was part of the
<a href=http://spinroot.com/gerard/1127_alumni.html>Computer Science Research Center</a>.
I left AT&amp;T Labs (one of the two successors to AT&amp;T Bell Labs) on good terms,
and was associated with AT&amp;T as an AT&amp;T Fellow for another decade.
<p>
<hr>
<h2><a name=working-on-now>What are you working on now?</a></h2>
A better FAQ :-)
<p>
Seriously, I'm looking for
fundamental ways of improving the tools and techniques we use to build
large real-world systems.
One part of my work is <a href=#When-next-standard>C++11</a>.
<p>
<hr>
<h2><a name=what-is>
What is C++?</a></h2>
C++ is a general-purpose programming language with a bias towards 
systems programming that
<ul>
<li>is <a href=#difference>a better C</a>
<li>supports <a href=#class>data abstraction</a>
<li>supports <a href=#oop>object-oriented programming</a>
<li>supports <a href=#generic>generic programming</a>
</ul>
It is defined by
<a href=https://www.stroustrup.com/C++.html>an ISO standard</a>,
offers stability over decades,
and has a large and lively user community.
See also
<a href=https://www.stroustrup.com/4th.html>The C++ Programming Language</a> and
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>Evolving a language in and for the real world: C++ 1991-2006</a>.
<p>
<hr>
<h2><a name=background>
Where can I learn about the background of C++?</a></h2>
About the design of C++? About the history of C++?
<p>
Look at my papers for
<a href=https://www.stroustrup.com/hopl2.pdf>HOPL-2</a> and
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>HOPL-3</a>;
HOPL stands for "History Of Programming Languages", the premier 
conference on that subject, sponsored by the ACM. These are heavily 
peer-reviewed papers.
For even more information see my book
<a href=https://www.stroustrup.com/dne.html>The Design and Evolution of C++</a> and the
<a href=https://www.stroustrup.com/DnE2005.pdf>Preface to the 2006 Japanese translation of D&amp;E</a>
which brings the information up to 2006.
Also, many of my
<a href=https://www.stroustrup.com/interviews.html>interviews</a>
touch upon the issues of background, design, and history of C++.
<p>
<hr>
<h2><a name=true>
Is it true that ...?</a></h2>
Many questions come to me in the form of assertions
<ul>
<li>C++ is low-level(?)
<li>C++ is too slow for low-level work(?)
<li>C++ is useful only if you write truly object-oriented code(?)
<li>Modern C++ is all generic programming and template metaprogramming(?)
<li>C++ is designed by Microsoft(?)
</ul>
Often, the person bringing up one of these points considers the 
statement a fact (but none of these assertions are true);
sometimes, there is an implied question mark. So,
<ul>
<li><i>C++ is low-level?</i>
No. C++ offers both low-level and high-level features.
C++ has low-level parts, such as pointers, arrays, and casts.
These facilities are
(<a href=#difference>almost identical to what C offers</a>)
are essential (in some form or other) for close-to-the-hardware work.
So, if you want low-level language facilities, yes C++ provides a 
well-tried set of facilities for you.
However, when you don't want to use low-level features, you don't need 
to use the C++ facilities (directly). Instead, you can rely on 
higher-level facilities, including libraries.
For example, if you don't want to use arrays and pointers, standard 
library strings and containers are (better) alternatives in many cases.
If you use only low-level facilities, you are almost certainly wasting 
time and complicating maintenance without performance advantages
(see <a href=https://www.stroustrup.com/new_learning.pdf> Learning Standard C++ as a New Language</a>).
You may also be laying your systems open to attacks (e.g. buffer overflows).
<li><i>C++ too slow for low-level work?</i>
No. If you can afford to use C, you can afford to use C++, even the 
higher-level facilities of C++ where you need their functionality.
See
<a href=https://www.stroustrup.com/abstraction-and-machine.pdf>Abstraction and the C++ machine model</a>
and the ISO C++ standards committee's
<a href=https://www.stroustrup.com/performanceTR.pdf>Technical Report on Performance</a>.
<li><i>C++ is useful only if you write truly object-oriented code?</i>
No.
That is, "no" for just about any reasonable definition of "object-oriented".
C++ provides support for a wide variety of needs, not just for one style 
or for one kind of application.
In fact, compared to C, C++ provides more support for very simple programming tasks.
For example, the standard library and other libraries radically 
simplifies many otherwise tedious and error-prone tasks.
C++ is widely used for huge
<a href=https://www.stroustrup.com/applications.html>applications</a>
but it also provides benefits for even tiny programming tasks.
<li><i>Modern C++ is all generic programming and template metaprogramming?</i>
No.
C++ supports
<a href=#multiparadigm>several useful programming techniques</a>, 
including, traditional procedural programming, object-oriented 
programming, and generic programming.
None of these is better than all others for all uses and typically the 
most effective solution to a real-world problem involves a combination 
of techniques.
<li><i>C++ is designed by Microsoft?</i>
No.
<a href="https://www.stroustrup.com/href=">I originally designed and implemented C++</a> and
<a href=https://www.stroustrup.com/hopl-almost-final.pdf>together with the ISO C++ standards committee refined its definition</a>.
Microsoft has taken an active and largely positive role in this standardization
- as has Apple, GNU, IBM, Sun, and many others.
Like others - e.g. Apple - Microsoft tries to help/lock-in their users with proprietary extensions,
(in particular, <a href=#CppCLI>Microsoft C++/CLI</a>).
</ul>
<p>
<hr>
<h2><a name=boost>
What do you think of Boost?</a></h2>
<a href=http://www.boost.org/>Boost</a> is a large and expanding
<a href=http://www.boost.org/doc/libs>collection of libraries</a>
designed to work well with the ISO C++ standard library.
It contains many extremely useful and well-engineered libraries, such as asio, filesystem, 
regex, and thread (apologies for not trying to identify more useful 
libraries; there are just too many).
One library, TR1, contains a good approximation of new C++11 standard 
library components.
<p>
The Boost libraries have tests suites, have documentation, have been tested on multiple systems,
and are peer reviewed.
<p>
I have two problems with Boost, though, which I hope will be dealt with eventually:
<ul>
<li>It is too hard to download and use just one Boost library; the 
libraries seem overly coupled making it hard to pick and choose.
<li>Some of the libraries are too clever for my taste. Sometimes, 
generality and simplicity coincide; in Boost, the balance is IMO too 
often so far towards generality that novices and average users are lost.
</ul>
That said, it is usually a really dumb idea to go and reinvent a wheel 
that boost already offers.
<p>
<hr>
<h2><a name=rogramming>
What do you think of template metaprogramming?</a></h2>
Template metaprogramming is a set of powerful programming techniques, 
which when used with care and taste can help solve quite tricky problems, mostly 
relating to the architecture of larger systems, their portability, and 
their maintenance (see Abrahams and Gurtovoy:
<a href="http://www.informit.com/store/product.aspx?isbn=0321227255">C++ Template Metaprogramming</a> and some of
<a href=http://www.boost.org/>the Boost libraries</a>.
<p>
Like all powerful techniques they are easily overused.
Personally, I 
tend to use templates primarily for generic programming (e.g., defining 
containers and algorithms over containers) and for templates that 
generate fairly obvious code based on template arguments (e.g., 
generating buffers and register access code); that's sometimes called 
generative programming.
Be careful about the complexity of the templates 
you write or use; it is easy to get overenthusiastic and write template 
code that is too clever to be useful as maintainable production code.
<p>
If you do not like functional programming styles, you might find 
template metaprograms hard to understand. If you do like functional 
programming, you may find the template version a bit primitive, but 
remember these templates are executed at compile-time.
<p>
C++'s support for metaprogramming is improving.
<a href=http://www.stroustrup.com/good_concepts.pdf>Concepts</a>
will dramatically simplify generic programming and make much of the scaffolding for template metaprogramming redundant.
Furthermore if what you want to generate is a value (say and integer value),
<a href=http://en.cppreference.com/w/cpp/language/constexpr>constexpr functions</a>
are far easier to use (and compile faster).
</p><center>
<a href=http://www.morganstanley.com/>Morgan Stanley</a>
|
<a href=http://www.cs.columbia.edu/>Columbia University</a>
|
<a href=https://www.chu.cam.ac.uk/>Churchill College, Cambridge</a>
</center>
<p>
</p><center>
<a href=https://www.stroustrup.com/index.html>home</a>
|
<a href=https://www.stroustrup.com/C++.html>C++</a>
|
<a href=https://www.stroustrup.com/bs_faq.html>FAQ</a>
|
<a href=https://www.stroustrup.com/bs_faq2.html>technical FAQ</a>
|
<a href=https://www.stroustrup.com/papers.html>publications</a>
|
<a href=https://www.stroustrup.com/WG21.html>WG21 papers</a>
|
<a href=https://www.stroustrup.com/4th.html>TC++PL</a>
|
<a href=https://www.stroustrup.com/tour2.html>Tour++</a>
|
<a href=https://www.stroustrup.com/programming.html>Programming</a>
|
<a href=https://www.stroustrup.com/dne.html>D&amp;E</a>
|
<a href=https://www.stroustrup.com/bio.html>bio</a>
|
<a href=https://www.stroustrup.com/interviews.html>interviews</a>
|
<a href=https://www.stroustrup.com/videos.html>videos</a>
|
<a href=https://www.stroustrup.com/quotes.html>quotes</a>
|
<a href=https://www.stroustrup.com/applications.html>applications</a>
|
<a href=https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>guidelines</a>
|
<a href=https://www.stroustrup.com/compilers.html>compilers</a>
</center>
